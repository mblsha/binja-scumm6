"""Concrete SCUMM6 instruction implementations."""

from typing import List
from binja_helpers.tokens import Token, TInstr, TSep, TInt
from binaryninja.lowlevelil import LowLevelILFunction, LLIL_TEMP
from binaryninja import IntrinsicName
from ...scumm6_opcodes import Scumm6Opcodes

from .opcodes import Instruction
from .generic import BinaryStackOp, UnaryStackOp, ComparisonStackOp, VariableWriteOp

# Import the vars module to use the same LLIL generation logic
from ... import vars


# PushByte and PushWord are now generated by factories in opcode_table.py


class PushByteVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_byte_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteData), \
            f"Expected ByteData body, got {type(self.op_details.body)}"

        # Create a wrapper that adds the missing type attribute for compatibility
        # with the existing vars.il_get_var function
        class VarBlock:
            def __init__(self, data: int, var_type: Scumm6Opcodes.VarType):
                self.data = data
                self.type = var_type

        var_block = VarBlock(self.op_details.body.data, Scumm6Opcodes.VarType.scumm_var)
        il.append(il.push(4, vars.il_get_var(il, var_block)))


class PushWordVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_word_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        il.append(il.push(4, vars.il_get_var(il, self.op_details.body)))


class Dup(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dup")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.NoData), \
            f"Expected NoData body, got {type(self.op_details.body)}"

        # Pop value into temp register, then push it twice
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# Pop1 and Pop2 are now generated by factories in opcode_table.py


class Add(BinaryStackOp):
    il_op_name = "add"


class Sub(BinaryStackOp):
    il_op_name = "sub"


class Mul(BinaryStackOp):
    il_op_name = "mult"  # Note: IL method is mult


class Div(BinaryStackOp):
    il_op_name = "div_signed"


class Land(BinaryStackOp):
    il_op_name = "and_expr"


class Lor(BinaryStackOp):
    il_op_name = "or_expr"


class Nott(UnaryStackOp):
    il_op_name = "nott"
    needs_comparison_with_zero = True


class Eq(ComparisonStackOp):
    il_op_name = "compare_equal"


class Neq(ComparisonStackOp):
    il_op_name = "compare_not_equal"


class Gt(ComparisonStackOp):
    il_op_name = "compare_signed_greater_than"


class Lt(ComparisonStackOp):
    il_op_name = "compare_signed_less_than"


class Le(ComparisonStackOp):
    il_op_name = "compare_signed_less_equal"


class Ge(ComparisonStackOp):
    il_op_name = "compare_signed_greater_equal"


# Abs is now generated by factory in opcode_table.py


class Band(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("band")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Bor(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("bor")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class WordVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class ByteVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


class WordVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


# BreakHere is now generated by factory in opcode_table.py


class Dummy(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dummy")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


# GetRandomNumber and GetRandomNumberRange are now generated by factories in opcode_table.py


class PickOneOf(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class PickOneOfDefault(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of_default")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Shuffle(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("shuffle")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayRead), \
            f"Expected ByteArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WriteByteVar(VariableWriteOp):
    instruction_name = "write_byte_var"
    expected_body_type = Scumm6Opcodes.ByteVarData


class WriteWordVar(VariableWriteOp):
    instruction_name = "write_word_var" 
    expected_body_type = Scumm6Opcodes.WordVarData


class WordArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayRead), \
            f"Expected WordArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedRead), \
            f"Expected ByteArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedRead), \
            f"Expected WordArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation  
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayWrite), \
            f"Expected ByteArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayWrite), \
            f"Expected WordArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedWrite), \
            f"Expected ByteArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedWrite), \
            f"Expected WordArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())
