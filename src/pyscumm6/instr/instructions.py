"""Concrete SCUMM6 instruction implementations."""

from typing import List, Any, Optional, Tuple, cast
import copy
from binja_helpers.tokens import Token, TInstr, TSep, TInt, TText
from binaryninja.lowlevelil import LowLevelILFunction, LLIL_TEMP, LowLevelILLabel
from binaryninja import IntrinsicName, InstructionInfo
from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]

from .opcodes import Instruction
from .generic import VariableWriteOp, ControlFlowOp, IntrinsicOp
from .smart_bases import SmartConditionalJump, FusibleMultiOperandMixin

# Import the vars module to use the same LLIL generation logic
from ... import vars

# Array ID to name mapping based on descumm
SCUMM_ARRAY_NAMES = {
    110: "VAR_GUI_COLORS",  # 0x6E
    236: "array236",  # 0xEC - no descumm name known yet
    24013: "VAR_PAUSE_MSG",  # 0x5DCD
    # Add more mappings as discovered
}


# PushByte and PushWord are now generated by factories in opcode_table.py


class PushByteVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_byte_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteData), \
            f"Expected ByteData body, got {type(self.op_details.body)}"

        # Create a wrapper that adds the missing type attribute for compatibility
        # with the existing vars.il_get_var function
        class VarBlock:
            def __init__(self, data: int, var_type: Scumm6Opcodes.VarType):
                self.data = data
                self.type = var_type

        var_block = VarBlock(self.op_details.body.data, Scumm6Opcodes.VarType.scumm_var)
        il.append(il.push(4, vars.il_get_var(il, var_block)))


class PushWordVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_word_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        il.append(il.push(4, vars.il_get_var(il, self.op_details.body)))


class Dup(Instruction):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        return [TInstr("dup")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.NoData), \
            f"Expected NoData body, got {type(self.op_details.body)}"

        # Pop value into temp register, then push it twice
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# Pop1 and Pop2 are now generated by factories in opcode_table.py
# Add, Sub, Mul, Div, Land, Lor, Nott, Eq, Neq, Gt, Lt, Le, Ge are now generated by factories in opcode_table.py


# Abs is now generated by factory in opcode_table.py


class Band(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("band")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Bor(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("bor")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class WordVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class ByteVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


class WordVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


# BreakHere is now generated by factory in opcode_table.py


class Dummy(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dummy")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


# GetRandomNumber and GetRandomNumberRange are now generated by factories in opcode_table.py


class PickOneOf(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class PickOneOfDefault(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of_default")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Shuffle(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("shuffle")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        array_name = SCUMM_ARRAY_NAMES.get(array_id, f"array_{array_id}")
        return [
            TInstr("byte_array_read"),
            TSep("("),
            TInt(array_name),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayRead), \
            f"Expected ByteArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WriteByteVar(VariableWriteOp):
    instruction_name = "write_byte_var"
    expected_body_type = Scumm6Opcodes.ByteVarData


class WriteWordVar(VariableWriteOp):
    instruction_name = "write_word_var" 
    expected_body_type = Scumm6Opcodes.WordVarData


class WordArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        array_name = SCUMM_ARRAY_NAMES.get(array_id, f"array_{array_id}")
        return [
            TInstr("word_array_read"),
            TSep("("),
            TInt(array_name),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayRead), \
            f"Expected WordArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        array_name = SCUMM_ARRAY_NAMES.get(array_id, f"array_{array_id}")
        return [
            TInstr("byte_array_indexed_read"),
            TSep("("),
            TInt(array_name),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedRead), \
            f"Expected ByteArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        array_name = SCUMM_ARRAY_NAMES.get(array_id, f"array_{array_id}")
        return [
            TInstr("word_array_indexed_read"),
            TSep("("),
            TInt(array_name),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedRead), \
            f"Expected WordArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation  
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        array_name = SCUMM_ARRAY_NAMES.get(array_id, f"array_{array_id}")
        return [
            TInstr("byte_array_write"),
            TSep("("),
            TInt(array_name),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayWrite), \
            f"Expected ByteArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayWrite(FusibleMultiOperandMixin, Instruction):
    """Word array write with fusion support and descumm-style names."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List['Instruction'] = []
    
    @property
    def stack_pop_count(self) -> int:
        """Number of values this instruction pops from the stack."""
        if self.fused_operands:
            return 0  # Fused instructions handle their own operands
        return 2  # word_array_write pops index and value
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands this instruction can fuse."""
        return 2  # array write takes 2 parameters: index and value
    
    def fuse(self, previous: Instruction) -> Optional['WordArrayWrite']:
        """Attempt to fuse with previous instruction."""
        return cast(Optional['WordArrayWrite'], self._standard_fuse(previous))
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        else:
            return [TText("operand")]

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        array_name = SCUMM_ARRAY_NAMES.get(array_id, f"array_{array_id}")
        
        if self.fused_operands:
            # With fusion: show as assignment
            # IMPORTANT: The fusion order and descumm semantics require:
            # fused_operands[0] = first pushed = index
            # fused_operands[1] = last pushed = value
            # This produces the correct descumm output: array[index] = value
            if len(self.fused_operands) == 2:
                index_operand = self.fused_operands[0]  # First pushed = index
                value_operand = self.fused_operands[1]  # Last pushed = value
                
                tokens: List[Token] = []
                tokens.append(TText(array_name))
                tokens.append(TSep("["))
                tokens.extend(self._render_operand(index_operand))
                tokens.append(TSep("] = "))
                tokens.extend(self._render_operand(value_operand))
                return tokens
        
        # Without fusion: show function call style
        return [
            TInstr("word_array_write"),
            TSep("("),
            TInt(array_name),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayWrite), \
            f"Expected WordArrayWrite body, got {type(self.op_details.body)}"

        if self.fused_operands:
            # Use fused operands
            params = [self._lift_operand(il, op) for op in self.fused_operands]
            il.append(il.intrinsic(
                [il.reg(4, LLIL_TEMP(0))],
                IntrinsicName("word_array_write"),
                params
            ))
        else:
            # Generate intrinsic call - pops value and index, pushes result
            il.append(il.intrinsic(
                [il.reg(4, LLIL_TEMP(0))],  # output
                IntrinsicName("word_array_write"),  # intrinsic name
                [il.pop(4), il.pop(4)]  # parameters: pop value and index from stack
            ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        else:
            return il.const(4, 0)  # Placeholder


class ByteArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedWrite), \
            f"Expected ByteArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedWrite), \
            f"Expected WordArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Iff(ControlFlowOp):

    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        
        # Display absolute address like descumm if we have the current address
        if self.addr is not None:
            target_addr = self.addr + self.length() + jump_offset
            # Format as hex with leading zeros if negative (like descumm)
            if target_addr < 0:
                formatted_addr = f"{target_addr & 0xFFFFFFFF:x}"
            else:
                formatted_addr = f"{target_addr:x}"
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(formatted_addr),
            ]
        
        # Fallback to relative addressing if no address available
        if jump_offset > 0:
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        else:
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]

    def is_conditional(self) -> bool:
        return True

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition != 0, jump to target (iff = "if true")
        il.append(
            il.if_expr(
                il.compare_not_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class IfNot(ControlFlowOp):

    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        
        # Display absolute address like descumm if we have the current address
        if self.addr is not None:
            target_addr = self.addr + self.length() + jump_offset
            if jump_offset == 0:
                # Special case for zero offset (infinite loop)
                return [
                    TInstr("unless"),
                    TSep(" "),
                    TInstr("goto"),
                    TSep(" "),
                    TInstr("self"),
                ]
            else:
                # Format as hex with leading zeros if negative (like descumm)
                if target_addr < 0:
                    formatted_addr = f"{target_addr & 0xFFFFFFFF:x}"
                else:
                    formatted_addr = f"{target_addr:x}"
                return [
                    TInstr("unless"),
                    TSep(" "),
                    TInstr("goto"),
                    TSep(" "),
                    TInstr(formatted_addr),
                ]
        
        # Fallback to relative addressing if no address available
        if jump_offset > 0:
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        elif jump_offset < 0:
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]
        else:
            # Zero offset = skip next instruction if true
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr("self"),
            ]

    def is_conditional(self) -> bool:
        return True

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition == 0, jump to target (if_not = "if false")
        il.append(
            il.if_expr(
                il.compare_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class Jump(ControlFlowOp):

    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        
        # Display absolute address like descumm if we have the current address
        if self.addr is not None:
            target_addr = self.addr + self.length() + jump_offset
            if jump_offset == 0:
                # Special case for zero offset (infinite loop)
                return [
                    TInstr("jump"),
                    TSep(" "),
                    TInstr("self"),
                ]
            else:
                # Format as hex with leading zeros if negative (like descumm)
                if target_addr < 0:
                    formatted_addr = f"{target_addr & 0xFFFFFFFF:x}"
                else:
                    formatted_addr = f"{target_addr:x}"
                return [
                    TInstr("jump"),
                    TSep(" "),
                    TInstr(formatted_addr),
                ]
        
        # Fallback to relative addressing if no address available
        if jump_offset > 0:
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        elif jump_offset < 0:
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]
        else:
            # Zero offset = infinite loop
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr("self"),
            ]

    def is_conditional(self) -> bool:
        return False

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Unconditional jump to target
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        # Use const_pointer to ensure proper cross-references for inter-procedural jumps
        il.append(il.jump(il.const_pointer(il.arch.address_size, target_addr)))


class SmartIff(SmartConditionalJump):
    """Fusible 'if true' conditional jump instruction."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self._name = "iff"
        self._is_if_not = False  # This is 'if', not 'if_not'


class SmartIfNot(SmartConditionalJump):
    """Fusible 'if false/unless' conditional jump instruction."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self._name = "if_not"
        self._is_if_not = True  # This is 'if_not'


# =============================================================================
# Group 3: Complex Engine Intrinsics
# =============================================================================

# DrawObject, DrawObjectAt, DrawBlastObject are now generated by factories in opcode_table.py


class Cutscene(IntrinsicOp):
    """Start cutscene with variable number of parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "cutscene"
    
    @property
    def pop_count(self) -> int:
        """Cutscene uses call_func_list which requires complex argument parsing."""
        # For call_func_list, we need to look at the actual body to determine argument count
        if hasattr(self.op_details.body, 'args') and hasattr(self.op_details.body.args, '__len__'):
            return len(self.op_details.body.args)
        else:
            # Default to 0 if we can't determine the argument count
            return 0


# EndCutscene, StopMusic, FreezeUnfreeze are now generated by factories in opcode_table.py


class StopObjectCode1(IntrinsicOp):
    """Stop object code (variant 1) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code1"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


class StopObjectCode2(IntrinsicOp):
    """Stop object code (variant 2) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code2"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


# StopObjectScript, StartSound, StopSound, PanCameraTo, ActorFollowCamera, SetCameraAt, LoadRoom, GetState, SetState, SetOwner are now generated by factories


# Simple Actor Query Operations - now generated by factories
# GetOwner, IsScriptRunning, IsSoundRunning, GetActorMoving, GetActorRoom, GetActorCostume, GetActorWalkBox, GetInventoryCount, FindInventory, GetObjectX, GetObjectY, GetObjectOldDir are now generated by factories


# AnimateActor, FaceActor, PickupObject, SetBoxFlags, SetObjectName, DoSentence, GetActorElevation, GetActorWidth, GetActorScaleX, GetActorAnimCounter, GetVerbFromXy, GetActorFromXy are now generated by factories


# Zero-Parameter Intrinsics and Timing Operations - now generated by factories
# BeginOverride, EndOverride, CreateBoxMatrix, StopTalking, StopSentence, Wait, Delay, DelaySeconds, DelayMinutes, DelayFrames, StartMusic, StopScript are now generated by factories


# Distance/Geometry/Query/Movement Operations - now generated by factories  
# IsRoomScriptRunning, GetObjectNewDir, DistObjectObject, DistObjectPt, DistPtPt, GetPixel, FindObject, GetVerbEntrypoint, IsActorInBox, WalkActorToObj, WalkActorTo, PutActorAtXy are now generated by factories


# PutActorAtObject - now generated by factories from configs.py


# Additional Simple Operations (now generated by factories from configs.py)
# GetDatetime - now generated by factories from configs.py


# GetAnimateVariable - now generated by factories from configs.py


# PickVarRandom - now generated by factories from configs.py


# GetActorLayer - now generated by factories from configs.py


# Final Simple Utility Operations (now generated by factories from configs.py)
# CursorCommand - now generated by factories from configs.py


# SoundKludge - now generated by factories from configs.py


class IfClassOfIs(FusibleMultiOperandMixin, Instruction):
    """Check if object belongs to a specific class - pushes boolean result to stack."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _get_max_operands(self) -> int:
        """if_class_of_is takes 3 parameters: object, class_id, and count."""
        return 3
    
    def fuse(self, previous: Instruction) -> Optional['IfClassOfIs']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        # Normally pops 2 values (plus the count which is already on stack)
        # With full fusion, pops nothing
        return max(0, 3 - len(self.fused_operands))

    def render(self) -> List[Token]:
        if self.fused_operands and len(self.fused_operands) >= 2:
            # We have at least object and class fused
            tokens: List[Token] = []
            tokens.append(TInstr("ifClassOfIs"))
            tokens.append(TSep("("))
            
            # The stack order is: object, class, count
            # With LIFO fusion: fused_operands[0] is object (last fused), [1] is class, [2] is count (first fused)
            if len(self.fused_operands) >= 3:
                # Full fusion - show object
                # print(f"DEBUG: Rendering object operand: {self.fused_operands[0].__class__.__name__}")
                tokens.extend(self._render_operand(self.fused_operands[0]))
                tokens.append(TSep(","))
                tokens.append(TSep("["))
                # Show class ID
                # print(f"DEBUG: Rendering class operand: {self.fused_operands[1].__class__.__name__}")
                tokens.extend(self._render_operand(self.fused_operands[1]))
                tokens.append(TSep("]"))
            else:
                # Partial fusion
                tokens.append(TText("..."))
            
            tokens.append(TSep(")"))
            return tokens
        else:
            return [TInstr("if_class_of_is")]
    
    def produces_result(self) -> bool:
        """This instruction produces a boolean result that can be consumed."""
        return True
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        # Debug print to verify this method is being called
        # print(f"IfClassOfIs._render_operand called with {operand.__class__.__name__}")
        
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            var_num = operand.op_details.body.data if hasattr(operand.op_details.body, 'data') else 0
            # Check if it's explicitly marked as a local variable type
            if hasattr(operand.op_details.body, 'type'):
                from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
                if operand.op_details.body.type == Scumm6Opcodes.VarType.local:
                    return [TText(f"localvar{var_num}")]
                else:
                    return [TText(f"var_{var_num}")]
            # Otherwise check if it's in the local variable range (0-15)
            elif 0 <= var_num < 16:  # First 16 are local variables
                return [TText(f"localvar{var_num}")]
            else:
                return [TText(f"var_{var_num}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            value = operand.op_details.body.data if hasattr(operand.op_details.body, 'data') else 0
            return [TInt(str(value))]
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # This is a result-producing instruction
            tokens: List[Token] = []
            tokens.append(TText("("))
            tokens.extend(operand.render())
            tokens.append(TText(")"))
            return tokens
        else:
            return [TText("operand")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.IfClassOfIs), \
            f"Expected IfClassOfIs body, got {type(self.op_details.body)}"
        
        if self.fused_operands and len(self.fused_operands) >= 2:
            # Use fused operands
            if len(self.fused_operands) >= 3:
                # Full fusion: object, class, count
                # With LIFO: fused_operands[0] is object, [1] is class, [2] is count
                object_val = self._lift_operand(il, self.fused_operands[0])
                class_val = self._lift_operand(il, self.fused_operands[1])
            else:
                # Partial fusion - pop remaining from stack
                if len(self.fused_operands) == 2:
                    # We have class and count (object still on stack)
                    class_val = self._lift_operand(il, self.fused_operands[0])
                    object_val = il.pop(4)
                else:
                    # We have only count
                    class_val = il.pop(4)
                    object_val = il.pop(4)
        else:
            # No fusion - pop from stack
            class_val = il.pop(4)    # Pop class ID
            object_val = il.pop(4)   # Pop object ID
        
        # Call intrinsic to check if object is of specified class
        # This returns a boolean result (0 or 1)
        result = il.intrinsic([il.reg(4, LLIL_TEMP(0))], "if_class_of_is", [object_val, class_val])
        il.append(result)
        
        # Push the result to stack
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            var_num = operand.op_details.body.data if hasattr(operand.op_details.body, 'data') else 0
            return il.reg(4, f"var_{var_num}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            value = operand.op_details.body.data if hasattr(operand.op_details.body, 'data') else 0
            return il.const(4, value)
        else:
            return il.const(4, 0)  # Placeholder


# SetClass - now generated by factories from configs.py


# DrawBox - now generated by factories from configs.py


# IsAnyOf - now generated by factories from configs.py


# Additional Simple Script Operations (now generated by factories from configs.py)
# LoadRoomWithEgo - now generated by factories from configs.py


# SetBoxSet - now generated by factories from configs.py


# StampObject - now generated by factories from configs.py


# SetBlastObjectWindow - now generated by factories from configs.py


# PseudoRoom - now generated by factories from configs.py


# FindAllObjects - now generated by factories from configs.py


# Simple Script and Object Operations (now generated by factories from configs.py)
# JumpToScript - now generated by factories from configs.py


# StartObject - now generated by factories from configs.py


# StartObjectQuick - now generated by factories from configs.py


# Array Management Operations (now generated by factories from configs.py)
# DimArray - now generated by factories from configs.py


# Dim2dimArray - now generated by factories from configs.py


# Kernel Operations (now generated by factories from configs.py)
# KernelGetFunctions - now generated by factories from configs.py


# KernelSetFunctions - now generated by factories from configs.py


# Additional Utility Operations (now generated by factories from configs.py)
# SaveRestoreVerbs - custom implementation for sub-operation support

class SaveRestoreVerbs(FusibleMultiOperandMixin, Instruction):
    """Save/restore verbs operation with custom fusion support."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List['Instruction'] = []
    
    @property
    def stack_pop_count(self) -> int:
        """Number of values this instruction pops from the stack."""
        if self.fused_operands:
            return 0  # Fused instructions handle their own operands
        return 3  # save_restore_verbs pops 3 values
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands this instruction can fuse."""
        return 3  # saveRestoreVerbs takes 3 parameters
    
    def fuse(self, previous: Instruction) -> Optional['SaveRestoreVerbs']:
        """Attempt to fuse with previous instruction."""
        return cast(Optional['SaveRestoreVerbs'], self._standard_fuse(previous))
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        elif operand.produces_result():
            tokens: List[Token] = []
            tokens.append(TText("("))
            tokens.extend(operand.render())
            tokens.append(TText(")"))
            return tokens
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        elif operand.produces_result():
            return il.const(4, 0)  # Placeholder
        else:
            return il.const(4, 0)  # Placeholder
    
    def render(self) -> List[Token]:
        # Get sub-operation byte
        
        # The body should be CallFuncPop3Byte which has a param field
        subop_byte = self.op_details.body.param if hasattr(self.op_details.body, 'param') else 0
        
        # Map sub-operation byte to descumm-style names
        # Handle both signed and unsigned interpretation
        # 0x8D = 141 unsigned = -115 signed
        subop_names = {
            1: "saveVerbs",
            -115: "saveVerbs",  # 0x8D as signed byte
            141: "saveVerbs",   # 0x8D as unsigned byte
            # Add more mappings as we discover them
        }
        
        subop_name = subop_names.get(subop_byte, f"subop_{subop_byte}")
        display_name = f"saveRestoreVerbs.{subop_name}"
        
        # Handle fused operands
        if self.fused_operands:
            tokens = [TInstr(display_name), TSep("(")]
            # Render operands in push order (not reversed)
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TSep(")"))
            return tokens
        else:
            # No fusion - show with ellipsis
            return [TInstr(f"{display_name}(...)")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        
        # Get sub-operation byte
        subop_byte = self.op_details.body.param if hasattr(self.op_details.body, 'param') else 0
        intrinsic_name = f"save_restore_verbs.subop_{subop_byte}"
        
        if self.fused_operands:
            # Use fused operands directly
            params = [self._lift_operand(il, op) for op in self.fused_operands]
            il.append(il.intrinsic([], IntrinsicName(intrinsic_name), params))
        else:
            # Pop 3 arguments from stack
            params = [il.pop(4) for _ in range(3)]
            il.append(il.intrinsic([], IntrinsicName(intrinsic_name), params))


# Dialog and Text Operations (now generated by factories from configs.py)

class PrintLine(FusibleMultiOperandMixin, Instruction):
    """Print line operations with various formatting options."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # This is a result-producing instruction (like a fused expression)
            # Render it as a nested expression with parentheses
            tokens: List[Token] = []
            tokens.append(TText("("))
            tokens.extend(operand.render())
            tokens.append(TText(")"))
            return tokens
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # Complex case: would need to execute operand's lift method
            # For now, use placeholder - future enhancement needed
            return il.const(4, 0)  # Placeholder
        else:
            return il.const(4, 0)  # Placeholder
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop's pop_count."""
        subop_body = self.op_details.body.body
        return getattr(subop_body, "pop_count", 0)
    
    def fuse(self, previous: Instruction) -> Optional['PrintLine']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def render(self) -> List[Token]:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Handle both enum and int subop types
        if hasattr(self.op_details.body.subop, 'name'):
            subop_name = self.op_details.body.subop.name
        else:
            # Map integer subop values to names
            subop_int_map = {
                0x01: "overhead",
                0x02: "mumble",
                0x03: "textstring",
                0x04: "baseop",  # begin
                0x05: "endd",
                0x06: "color",
                0x07: "left",
                0x08: "at",  # XY
                0x09: "right",
                0x0A: "center",
                0x0B: "clipped",
            }
            subop_name = subop_int_map.get(self.op_details.body.subop, f"subop_{self.op_details.body.subop}")
        
        # Map subop names to descumm-style names
        subop_map = {
            "begin": "begin",
            "baseop": "begin",  # Alternative name for begin
            "color": "color",
            "center": "center",
            "charset": "charset",
            "left": "left",
            "overhead": "overhead",
            "mumble": "mumble",
            "msg": "msg",
            "textstring": "msg",  # Alternative name for msg
            "width": "width",
            "transparency": "transparency",
            "xy": "XY",  # Map xy to XY for descumm compatibility
            "at": "XY",  # Alternative name for XY
            "endd": "end",  # Map endd to end
            "right": "right",
        }
        
        # Use the mapped name or fall back to original
        display_subop = subop_map.get(subop_name, subop_name)
        display_name = f"printLine.{display_subop}"
        
        tokens: List[Token] = [TInstr(display_name)]
        
        # Check for specific body types
        subop_body = self.op_details.body.body
        
        if isinstance(subop_body, Scumm6Opcodes.CallFuncString):
            # String parameter (like msg)
            tokens.append(TText("("))
            # Handle complex string formatting
            string_data = subop_body.data
            # Basic handling of special sequences
            # TODO: Full descumm-style formatting with sound() and wait()
            if string_data:
                # For now, show raw string with escape sequences
                tokens.append(TText(f'"{string_data}"'))
            else:
                tokens.append(TText('""'))
            tokens.append(TText(")"))
        elif hasattr(subop_body, '__class__') and subop_body.__class__.__name__ == 'Message':
            # Complex message with parts (sound, text, wait, etc.)
            tokens.append(TText("("))
            # Parse the message parts to reconstruct descumm-style output
            if hasattr(subop_body, 'parts') and subop_body.parts:
                msg_tokens: List[Token] = []
                i = 0
                parts = subop_body.parts
                
                while i < len(parts) and parts[i].data != 0:
                    part = parts[i]
                    
                    if part.data == 0xff and hasattr(part, 'content'):
                        # Special sequence
                        special = part.content
                        if special.code == 0x0a:  # Sound command
                            # Sound command with inline values
                            if hasattr(special, 'payload'):
                                sound = special.payload
                                if hasattr(sound, 'value1') and hasattr(sound, 'v3'):
                                    sound_id = sound.value1
                                    volume = sound.v3
                                    if msg_tokens:
                                        msg_tokens.append(TText(" + "))
                                    msg_tokens.append(TText(f"sound(0x{sound_id:x}, 0x{volume:x})"))
                        elif special.code == 0x03:  # Wait command
                            if msg_tokens:
                                msg_tokens.append(TText(" + "))
                            msg_tokens.append(TText("wait()"))
                        # Other special codes can be added here
                    elif 32 <= part.data <= 126:
                        # Text run - collect consecutive printable characters
                        text = ""
                        while i < len(parts) and 32 <= parts[i].data <= 126:
                            text += chr(parts[i].data)
                            i += 1
                        if msg_tokens:
                            msg_tokens.append(TText(" + "))
                        msg_tokens.append(TText(f'"{text}"'))
                        i -= 1  # Back up since we'll increment at loop end
                    i += 1
                
                if msg_tokens:
                    tokens.extend(msg_tokens)
                else:
                    tokens.append(TText('""'))
            else:
                tokens.append(TText("..."))
            tokens.append(TText(")"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop0):
            # No parameters - just show empty parens
            tokens.append(TText("()"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop1):
            # Single parameter
            if self.fused_operands:
                tokens.append(TText("("))
                tokens.extend(self._render_operand(self.fused_operands[0]))
                tokens.append(TText(")"))
            else:
                tokens.append(TText("(...)"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop2):
            # Two parameters (like XY)
            if self.fused_operands and len(self.fused_operands) >= 2:
                tokens.append(TText("("))
                tokens.extend(self._render_operand(self.fused_operands[0]))
                tokens.append(TSep(", "))
                tokens.extend(self._render_operand(self.fused_operands[1]))
                tokens.append(TText(")"))
            else:
                tokens.append(TText("(...)"))
        elif self.fused_operands:
            # Regular parameters
            tokens.append(TText("("))
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TText(")"))
        else:
            # No fused operands, show (...)
            tokens.append(TText("(...)"))
        
        return tokens
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Generate LLIL for print line."""
        # For now, use intrinsic
        params = []
        
        # Add fused operands as direct parameters
        for operand in self.fused_operands:
            params.append(self._lift_operand(il, operand))
        
        # Add remaining stack pops
        for _ in range(self.stack_pop_count):
            params.append(il.pop(4))
        
        il.append(il.intrinsic(
            [],  # no output
            IntrinsicName("print_line"),
            params
        ))


# PrintText - now generated by factories from configs.py


class PrintDebug(Instruction):
    """Print debug with text parameter."""
    
    def _extract_message_text(self, message: Any) -> Tuple[List[str], str]:
        """Extract text from a SCUMM6 Message object, including sound commands.
        
        Returns:
            A tuple of (sound_commands, text_string)
        """
        sound_commands: List[str] = []
        text_chars: List[str] = []
        
        for part in message.parts:
            if hasattr(part, 'data'):
                if part.data == 0xFF:
                    # This might be a special sequence
                    if hasattr(part, 'content') and hasattr(part.content, 'payload'):
                        # Check if it's a Sound special sequence
                        payload = part.content.payload
                        if payload.__class__.__name__ == 'Sound':
                            # Extract sound parameters (v1 and v3, skip v2)
                            if hasattr(payload, 'v1') and hasattr(payload, 'v3'):
                                sound_commands.append(f"sound({hex(payload.v1).upper().replace('X', 'x')}, {hex(payload.v3).upper().replace('X', 'x')})")
                elif part.data != 0:  # Skip terminator
                    if hasattr(part, 'content'):
                        # Check if it's a RegularChar
                        if hasattr(part.content, 'value'):
                            # Convert byte value to character
                            char_value = part.content.value
                            if isinstance(char_value, int) and 32 <= char_value <= 126:  # Printable ASCII
                                text_chars.append(chr(char_value))
        
        # Return sound commands and text separately
        return sound_commands, ''.join(text_chars)
    
    def render(self) -> List[Token]:
        # Check if this instruction contains a message
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        if hasattr(self.op_details.body, 'subop') and hasattr(self.op_details.body, 'body'):
            # This is a Print structure with a subop
            if (self.op_details.body.subop == Scumm6Opcodes.SubopType.textstring and 
                isinstance(self.op_details.body.body, Scumm6Opcodes.Message)):
                # Extract the actual message text
                sound_commands, text = self._extract_message_text(self.op_details.body.body)
                
                tokens = [TInstr("printDebug"), TText(".msg(")]
                
                # Add sound commands and text
                if sound_commands:
                    # Add sound commands
                    for i, sound_cmd in enumerate(sound_commands):
                        if i > 0:
                            tokens.extend([TText(" + ")])
                        tokens.append(TInstr(sound_cmd))
                    
                    if text:
                        tokens.extend([TText(" + "), TText(f'"{text}"')])
                    else:
                        # Just sound, add empty string
                        tokens.extend([TText(" + "), TText('""')])
                elif text:
                    tokens.append(TText(f'"{text}"'))
                else:
                    # No text or sound
                    tokens.append(TText('""'))
                
                tokens.append(TText(")"))
                return tokens
            else:
                # Handle other subops like begin(), end(), etc.
                subop_name = self.op_details.body.subop.name
                # Map baseop to begin to match descumm format
                if subop_name == "baseop":
                    subop_name = "begin"
                return [TInstr("printDebug"), TText(f".{subop_name}()")]
        
        # Fallback for simple print_debug without subop
        return [TInstr("printDebug")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        # For LLIL, treat as a simple intrinsic
        il.append(il.intrinsic([], "print_debug", []))


# PrintSystem - now generated by factories from configs.py


class PrintText(Instruction):
    """Print text with various formatting options including printCursor."""
    
    def _extract_message_text(self, message: Any) -> str:
        """Extract text from a SCUMM6 Message object."""
        text_chars: List[str] = []
        
        for part in message.parts:
            if hasattr(part, 'data'):
                if part.data != 0 and part.data != 0xFF:  # Skip terminator and special sequences
                    if hasattr(part, 'content') and hasattr(part.content, 'value'):
                        # Convert byte value to character
                        char_value = part.content.value
                        if isinstance(char_value, int) and 32 <= char_value <= 126:  # Printable ASCII
                            text_chars.append(chr(char_value))
        
        return ''.join(text_chars)
    
    def render(self) -> List[Token]:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        if hasattr(self.op_details.body, 'subop') and hasattr(self.op_details.body, 'body'):
            # This is a Print structure with a subop
            subop_value = self.op_details.body.subop
            
            # Convert enum to int if needed
            if hasattr(subop_value, 'value'):
                subop_value = subop_value.value
            
            # Check if subop is 0x4B (75) which is printCursor.msg
            if subop_value == 0x4B:
                if isinstance(self.op_details.body.body, Scumm6Opcodes.Message):
                    # Extract the message text
                    text = self._extract_message_text(self.op_details.body.body)
                    return [
                        TInstr("printCursor"),
                        TText(".msg("),
                        TText(f'"{text}"'),
                        TText(")")
                    ]
                else:
                    # No message body
                    return [TInstr("printCursor"), TText(".msg()")]
            else:
                # Other subops - use generic rendering
                if hasattr(self.op_details.body.subop, 'name'):
                    subop_name = self.op_details.body.subop.name
                    return [TInstr("printText"), TText(f".{subop_name}()")]
        
        # Fallback for simple print_text without subop
        return [TInstr("printText")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        # For LLIL, treat as a simple intrinsic
        il.append(il.intrinsic([], "print_text", []))


# PrintActor - now generated by factories from configs.py


# PrintEgo - now generated by factories from configs.py


class TalkActor(FusibleMultiOperandMixin, Instruction):
    """Talk actor with string message and actor parameter."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
        self._stack_pop_count = 1  # Pops actor ID from stack by default
    
    @property
    def stack_pop_count(self) -> int:
        """Return 0 when fused, 1 when not fused."""
        return 0 if self.fused_operands else self._stack_pop_count
    
    def _extract_message_text(self, message: Any) -> Tuple[List[str], str]:
        """Extract text from a SCUMM6 Message object, including sound commands.
        
        Returns:
            A tuple of (sound_commands, text_string)
        """
        sound_commands: List[str] = []
        text_chars: List[str] = []
        
        for part in message.parts:
            if hasattr(part, 'data'):
                if part.data == 0xFF:
                    # This might be a special sequence
                    if hasattr(part, 'content') and hasattr(part.content, 'payload'):
                        # Check if it's a Sound special sequence
                        payload = part.content.payload
                        if payload.__class__.__name__ == 'Sound':
                            # Extract sound parameters (v1 and v3, skip v2)
                            if hasattr(payload, 'v1') and hasattr(payload, 'v3'):
                                sound_commands.append(f"sound({hex(payload.v1).upper().replace('X', 'x')}, {hex(payload.v3).upper().replace('X', 'x')})")
                elif part.data != 0:  # Skip terminator
                    if hasattr(part, 'content'):
                        # Check if it's a RegularChar
                        if hasattr(part.content, 'value'):
                            # Convert byte value to character
                            char_value = part.content.value
                            if isinstance(char_value, int) and 32 <= char_value <= 126:  # Printable ASCII
                                text_chars.append(chr(char_value))
        
        # Return sound commands and text separately
        return sound_commands, ''.join(text_chars)
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        else:
            return il.const(4, operand.op_details.body.data)
    
    def _is_fusible_push(self, instr: Instruction) -> bool:
        """Check if instruction is a push that can be fused."""
        return instr.__class__.__name__ in ['PushByte', 'PushWord', 'PushByteVar', 'PushWordVar']
    
    def render(self) -> List[Token]:
        # Extract the message text from the bytecode
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        sound_commands: List[str] = []
        text: str = ""
        # Check if the body is a Message
        if isinstance(self.op_details.body, Scumm6Opcodes.Message):
            sound_commands, text = self._extract_message_text(self.op_details.body)
        
        if self.fused_operands and len(self.fused_operands) >= 1:
            # We have the actor parameter fused
            tokens = [TInstr("talkActor"), TText("(")]
            
            # Add sound commands and text
            if sound_commands:
                # Add sound commands
                for i, sound_cmd in enumerate(sound_commands):
                    if i > 0:
                        tokens.extend([TText(" + ")])
                    tokens.append(TInstr(sound_cmd))
                
                if text:
                    tokens.extend([TText(" + "), TText(f'"{text}"')])
            elif text:
                tokens.append(TText(f'"{text}"'))
            else:
                tokens.append(TText("..."))
            
            # Add the actor parameter
            tokens.extend([TSep(", ")])
            tokens.extend(self._render_operand(self.fused_operands[0]))
            tokens.append(TText(")"))
            return tokens
        else:
            # No fusion - show simple form
            return [TInstr("talkActor"), TText("()")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        if self.fused_operands and len(self.fused_operands) >= 1:
            # Use fused actor parameter
            params = [self._lift_operand(il, self.fused_operands[0])]
            il.append(il.intrinsic([], "talk_actor", params))
        else:
            # Pop actor from stack
            params = [il.pop(4)]
            il.append(il.intrinsic([], "talk_actor", params))
    
    def fuse(self, previous: Instruction) -> Optional['TalkActor']:
        """Fuse with push instruction for actor parameter."""
        # Only fuse if we need an operand
        if len(self.fused_operands) >= 1:
            return None
            
        # Check if previous is a fusible push
        if not self._is_fusible_push(previous):
            return None
            
        # Create fused instruction
        fused = copy.deepcopy(self)
        fused.fused_operands.append(previous)
        fused._length = self._length + previous.length()
        return fused


# TalkEgo - now generated by factories from configs.py


# Complex Operations with Sub-commands
class CursorCommand(FusibleMultiOperandMixin, Instruction):
    """Cursor command operations with various sub-commands."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # This is a result-producing instruction (like a fused expression)
            # Render it as a nested expression with parentheses
            tokens: List[Token] = []
            tokens.append(TText("("))
            tokens.extend(operand.render())
            tokens.append(TText(")"))
            return tokens
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # Complex case: would need to execute operand's lift method
            # For now, use placeholder - future enhancement needed
            return il.const(4, 0)  # Placeholder
        else:
            return il.const(4, 0)  # Placeholder
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop's pop_count."""
        subop_body = self.op_details.body.body
        
        # Special handling for CallFuncList which uses pop_list instead of pop_count
        if hasattr(subop_body, "pop_list") and subop_body.pop_list:
            # For list operations, we need to get the count from the stack
            # This is a special case where we need to look at previous instructions
            # For now, return a reasonable default for charsetColors (3 params)
            if self.op_details.body.subop.name == "charset_color":
                # The last fused operand should be the count
                if self.fused_operands and len(self.fused_operands) > 0:
                    last_operand = self.fused_operands[-1]
                    if hasattr(last_operand.op_details.body, 'data'):
                        return int(last_operand.op_details.body.data)
                return 4  # Default: count + 3 colors
            return 0
        
        return getattr(subop_body, "pop_count", 0)
    
    def fuse(self, previous: Instruction) -> Optional['CursorCommand']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def render(self) -> List[Token]:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        subop_name = self.op_details.body.subop.name
        
        # Map subop names to descumm-style names
        subop_map = {
            "charset_set": "initCharset",
            "charset_color": "charsetColors",
            "cursor_on": "on",
            "cursor_off": "off",
            "cursor_soft_on": "softOn",
            "cursor_soft_off": "softOff",
            "userput_on": "userputOn",
            "userput_off": "userputOff",
            "userput_soft_on": "userputSoftOn",
            "userput_soft_off": "userputSoftOff",
            "cursor_image": "image",
            "cursor_hotspot": "hotspot",
            "cursor_transparent": "transparent",
        }
        
        # Use the mapped name or fall back to original
        display_subop = subop_map.get(subop_name, subop_name)
        display_name = f"cursorCommand.{display_subop}"
        
        tokens: List[Token] = [TInstr(display_name)]
        
        # Check for specific body types
        subop_body = self.op_details.body.body
        
        if isinstance(subop_body, Scumm6Opcodes.CallFuncPop0):
            # No parameters - just show empty parens
            if not self.fused_operands:
                tokens.append(TText("()"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncList):
            # List parameter (for charset_color)
            tokens.append(TText("("))
            if self.fused_operands:
                # The last operand is the count, the rest are the values
                if len(self.fused_operands) > 0:
                    # Extract count from last operand
                    count_operand = self.fused_operands[-1]
                    if hasattr(count_operand.op_details.body, 'data'):
                        count = count_operand.op_details.body.data
                        # Show as array, excluding the count
                        tokens.append(TText("["))
                        # Show the actual values (all operands except the last one)
                        value_operands = self.fused_operands[:-1]
                        for i, operand in enumerate(value_operands[:count]):
                            if i > 0:
                                tokens.append(TSep(", "))
                            tokens.extend(self._render_operand(operand))
                        tokens.append(TText("]"))
                    else:
                        # Fallback if we can't extract count
                        tokens.append(TText("[..."))
                else:
                    tokens.append(TText("[]"))
            else:
                tokens.append(TText("..."))
            tokens.append(TText(")"))
        elif self.fused_operands:
            # Regular parameters
            tokens.append(TText("("))
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TText(")"))
        else:
            # No fused operands, show (...)
            tokens.append(TText("(...)"))
        
        return tokens
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Generate LLIL for cursor command."""
        # For now, use intrinsic
        params = []
        
        # Add fused operands as direct parameters
        for operand in self.fused_operands:
            params.append(self._lift_operand(il, operand))
        
        # Add remaining stack pops
        for _ in range(self.stack_pop_count):
            params.append(il.pop(4))
        
        il.append(il.intrinsic(
            [],  # no output
            IntrinsicName("cursor_command"),
            params
        ))


class PrintActor(FusibleMultiOperandMixin, Instruction):
    """Print actor dialog operations with various formatting options."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # This is a result-producing instruction (like a fused expression)
            # Render it as a nested expression with parentheses
            tokens: List[Token] = []
            tokens.append(TText("("))
            tokens.extend(operand.render())
            tokens.append(TText(")"))
            return tokens
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # Complex case: would need to execute operand's lift method
            # For now, use placeholder - future enhancement needed
            return il.const(4, 0)  # Placeholder
        else:
            return il.const(4, 0)  # Placeholder
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop's pop_count."""
        subop_body = self.op_details.body.body
        
        # Special handling for begin/baseop subop which takes actor ID
        if self.op_details.body.subop.name in ["begin", "baseop"]:
            return 1  # Actor ID
        
        return getattr(subop_body, "pop_count", 0)
    
    def fuse(self, previous: Instruction) -> Optional['PrintActor']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def render(self) -> List[Token]:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        subop_name = self.op_details.body.subop.name
        
        # Map subop names to descumm-style names
        subop_map = {
            "begin": "begin",
            "baseop": "begin",  # Alternative name for begin
            "color": "color",
            "center": "center",
            "charset": "charset",
            "left": "left",
            "overhead": "overhead",
            "mumble": "mumble",
            "msg": "msg",
            "textstring": "msg",  # Alternative name for msg
            "width": "width",
            "transparency": "transparency",
        }
        
        # Use the mapped name or fall back to original
        display_subop = subop_map.get(subop_name, subop_name)
        display_name = f"printActor.{display_subop}"
        
        tokens: List[Token] = [TInstr(display_name)]
        
        # Check for specific body types
        subop_body = self.op_details.body.body
        
        if isinstance(subop_body, Scumm6Opcodes.CallFuncString):
            # String parameter (like msg)
            tokens.append(TText("("))
            # Handle complex string formatting
            string_data = subop_body.data
            # Basic handling of special sequences
            # TODO: Full descumm-style formatting with sound() and wait()
            if string_data:
                # For now, show raw string with escape sequences
                tokens.append(TText(f'"{string_data}"'))
            else:
                tokens.append(TText('""'))
            tokens.append(TText(")"))
        elif hasattr(subop_body, '__class__') and subop_body.__class__.__name__ == 'Message':
            # Complex message with parts (sound, text, wait, etc.)
            tokens.append(TText("("))
            # Parse the message parts to reconstruct descumm-style output
            if hasattr(subop_body, 'parts') and subop_body.parts:
                msg_tokens: List[Token] = []
                i = 0
                parts = subop_body.parts
                
                while i < len(parts) and parts[i].data != 0:
                    part = parts[i]
                    
                    if part.data == 0xff and hasattr(part, 'content'):
                        # Special sequence
                        special = part.content
                        if special.code == 0x0a:  # Sound command
                            # Sound command with inline values
                            if hasattr(special, 'payload'):
                                sound = special.payload
                                if hasattr(sound, 'value1') and hasattr(sound, 'v3'):
                                    sound_id = sound.value1
                                    volume = sound.v3
                                    if msg_tokens:
                                        msg_tokens.append(TText(" + "))
                                    msg_tokens.append(TText(f"sound(0x{sound_id:x}, 0x{volume:x})"))
                        elif special.code == 0x03:  # Wait command
                            if msg_tokens:
                                msg_tokens.append(TText(" + "))
                            msg_tokens.append(TText("wait()"))
                        # Other special codes can be added here
                    elif 32 <= part.data <= 126:
                        # Text run - collect consecutive printable characters
                        text = ""
                        while i < len(parts) and 32 <= parts[i].data <= 126:
                            text += chr(parts[i].data)
                            i += 1
                        if msg_tokens:
                            msg_tokens.append(TText(" + "))
                        msg_tokens.append(TText(f'"{text}"'))
                        i -= 1  # Back up since we'll increment at loop end
                    i += 1
                
                if msg_tokens:
                    tokens.extend(msg_tokens)
                else:
                    tokens.append(TText('""'))
            else:
                tokens.append(TText("..."))
            tokens.append(TText(")"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop0):
            # No parameters - just show empty parens
            if not self.fused_operands:
                tokens.append(TText("()"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop1):
            # Single parameter
            if self.fused_operands:
                tokens.append(TText("("))
                tokens.extend(self._render_operand(self.fused_operands[0]))
                tokens.append(TText(")"))
            else:
                tokens.append(TText("(...)"))
        elif self.fused_operands:
            # Regular parameters
            tokens.append(TText("("))
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TText(")"))
        else:
            # No fused operands, show (...)
            tokens.append(TText("(...)"))
        
        return tokens
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Generate LLIL for print actor."""
        # For now, use intrinsic
        params = []
        
        # Add fused operands as direct parameters
        for operand in self.fused_operands:
            params.append(self._lift_operand(il, operand))
        
        # Add remaining stack pops
        for _ in range(self.stack_pop_count):
            params.append(il.pop(4))
        
        il.append(il.intrinsic(
            [],  # no output
            IntrinsicName("print_actor"),
            params
        ))


class PrintEgo(PrintActor):
    """Print ego dialog operations - same as PrintActor but for ego."""
    
    def render(self) -> List[Token]:
        # Get tokens from parent class
        tokens = super().render()
        # Replace printActor with printEgo
        if tokens and hasattr(tokens[0], 'text'):
            tokens[0] = TInstr(tokens[0].text.replace('printActor', 'printEgo'))
        return tokens
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Generate LLIL for print ego."""
        # Similar to PrintActor but with different intrinsic name
        params = []
        
        # Add fused operands as direct parameters
        for operand in self.fused_operands:
            params.append(self._lift_operand(il, operand))
        
        # Add remaining stack pops
        for _ in range(self.stack_pop_count):
            params.append(il.pop(4))
        
        il.append(il.intrinsic(
            [],  # no output
            IntrinsicName("print_ego"),
            params
        ))


class ActorOps(FusibleMultiOperandMixin, Instruction):
    """Actor operations with various sub-commands."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop's pop_count."""
        subop_body = self.op_details.body.body
        return getattr(subop_body, "pop_count", 0)
    
    def fuse(self, previous: Instruction) -> Optional['ActorOps']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def render(self) -> List[Token]:
        from .smart_bases import DESCUMM_FUNCTION_NAMES
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        subop_name = self.op_details.body.subop.name
        full_name = f"actor_ops.{subop_name}"
        display_name = DESCUMM_FUNCTION_NAMES.get(full_name, full_name)
        
        tokens: List[Token] = [TInstr(display_name)]
        
        # Check if this subop has string data (like actor_name)
        subop_body = self.op_details.body.body
        if isinstance(subop_body, Scumm6Opcodes.CallFuncString):
            # String parameter
            tokens.append(TText("("))
            tokens.append(TText(f'"{subop_body.data}"'))
            tokens.append(TText(")"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop0):
            # No parameters - just show empty parens if there's nothing fused
            if not self.fused_operands:
                tokens.append(TText("()"))
        elif self.fused_operands:
            # Add fused operand parameters
            tokens.append(TText("("))
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TText(")"))
        else:
            # No fusion and not handled above - show empty parens
            tokens.append(TText("()"))
        
        return tokens
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            if hasattr(operand.op_details.body, 'data'):
                return [TInt(f"var_{operand.op_details.body.data}")]
            else:
                return [TInt("var_?")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            if hasattr(operand.op_details.body, 'data'):
                value = operand.op_details.body.data
                return [TInt(str(value))]
            else:
                return [TInt("?")]
        else:
            return [TText("operand")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ActorOps), \
            f"Expected ActorOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"actor_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Build parameters
        if self.fused_operands:
            # Use fused operands directly
            params = []
            for operand in self.fused_operands:
                params.append(self._lift_operand(il, operand))
            # Pop any remaining arguments
            remaining_pops = pop_count - len(self.fused_operands)
            for _ in range(remaining_pops):
                params.append(il.pop(4))
        else:
            # Pop all arguments from stack
            params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        from ... import vars
        
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            # Variable push - use il_get_var
            return vars.il_get_var(il, operand.op_details.body)
        else:
            # Constant push - use const
            if hasattr(operand.op_details.body, 'data'):
                value = operand.op_details.body.data
                return il.const(4, value)
        
        # Fallback to undefined
        return il.undefined()


class VerbOps(FusibleMultiOperandMixin, Instruction):
    """Verb operations with various sub-commands."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        super().__init__(kaitai_op, length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop's pop_count."""
        subop_body = self.op_details.body.body
        return getattr(subop_body, "pop_count", 0)
    
    def fuse(self, previous: Instruction) -> Optional['VerbOps']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def _extract_message_text(self, message: Any) -> str:
        """Extract string from a Message object."""
        text_parts = []
        for part in message.parts:
            if hasattr(part, 'data'):
                if isinstance(part.data, bytes):
                    try:
                        decoded = part.data.decode('iso-8859-1').rstrip('\x00')
                        text_parts.append(decoded)
                    except UnicodeDecodeError:
                        pass
                elif isinstance(part.data, str):
                    text_parts.append(part.data)
                elif isinstance(part.data, int) and 32 <= part.data <= 126:
                    text_parts.append(chr(part.data))
        
        return ''.join(text_parts)
    
    def render(self) -> List[Token]:
        from .smart_bases import DESCUMM_FUNCTION_NAMES
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        subop_name = self.op_details.body.subop.name
        full_name = f"verb_ops.{subop_name}"
        display_name = DESCUMM_FUNCTION_NAMES.get(full_name, full_name)
        
        tokens: List[Token] = [TInstr(display_name)]
        
        # Check if this subop has message data (like verb_name)
        subop_body = self.op_details.body.body
        if isinstance(subop_body, Scumm6Opcodes.Message):
            # Message parameter - extract the text
            tokens.append(TText("("))
            text = self._extract_message_text(subop_body)
            tokens.append(TText(f'"{text}"'))
            tokens.append(TText(")"))
        elif isinstance(subop_body, Scumm6Opcodes.CallFuncPop0):
            # No parameters - just show empty parens
            tokens.append(TText("()"))
        elif self.fused_operands:
            # Add fused operand parameters
            tokens.append(TText("("))
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TText(")"))
        elif getattr(subop_body, "pop_count", 0) > 0:
            # Has parameters but not fused
            tokens.append(TText("(...)"))
        else:
            # No parameters
            tokens.append(TText("()"))
        
        return tokens
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            if hasattr(operand.op_details.body, 'data'):
                return [TInt(f"var_{operand.op_details.body.data}")]
            else:
                return [TInt("var_?")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            if hasattr(operand.op_details.body, 'data'):
                value = operand.op_details.body.data
                return [TInt(str(value))]
            else:
                return [TInt("?")]
        else:
            return [TText("operand")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.VerbOps), \
            f"Expected VerbOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"verb_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Build parameters
        if self.fused_operands:
            # Use fused operands directly
            params = []
            for operand in self.fused_operands:
                params.append(self._lift_operand(il, operand))
            # Pop any remaining arguments
            remaining_pops = pop_count - len(self.fused_operands)
            for _ in range(remaining_pops):
                params.append(il.pop(4))
        else:
            # Pop arguments normally
            params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        else:
            return il.const(4, 0)  # Placeholder


class ArrayOps(FusibleMultiOperandMixin, Instruction):
    """Array operations with various sub-commands."""
    
    def __init__(self, kaitai_op: Any, length: int, addr: Optional[int] = None) -> None:
        # Check if we need to fix the length for assign_string with UnknownOp
        actual_length = length
        if hasattr(kaitai_op, 'body') and hasattr(kaitai_op.body, 'subop'):
            subop_value = kaitai_op.body.subop if isinstance(kaitai_op.body.subop, int) else kaitai_op.body.subop.value
            if subop_value == 0:  # assign_string
                # Check if it parsed as UnknownOp (which reads too much)
                if hasattr(kaitai_op.body, 'body') and hasattr(kaitai_op.body.body, 'data'):
                    # Manually calculate the correct length
                    # Format: opcode(1) + array(2) + subop(1) + message(variable)
                    data = kaitai_op.body.body.data
                    if isinstance(data, (bytes, bytearray)):
                        # Find null terminator
                        null_pos = data.find(0)
                        if null_pos >= 0:
                            # Correct length = 4 (opcode + array + subop) + message length + 1 (null)
                            actual_length = 4 + null_pos + 1
        
        super().__init__(kaitai_op, actual_length, addr)
        self.fused_operands: List[Instruction] = []
    
    def _extract_message_text(self, message: Any) -> str:
        """Extract text from a SCUMM6 Message object.
        
        Returns:
            The extracted text string
        """
        text_chars: List[str] = []
        
        for part in message.parts:
            if hasattr(part, 'data'):
                if part.data != 0 and part.data != 0xFF:  # Skip terminator and special sequences
                    if 32 <= part.data <= 126:  # Printable ASCII
                        text_chars.append(chr(part.data))
        
        return ''.join(text_chars)
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop."""
        # Handle both enum and integer subop types
        if hasattr(self.op_details.body.subop, 'name'):
            subop_name = self.op_details.body.subop.name
        else:
            # Map integer subop values to names
            subop_int_map = {
                0x00: "assign_string",
                # Add more mappings as needed
            }
            subop_value = self.op_details.body.subop
            subop_name = subop_int_map.get(subop_value, f"unknown_{subop_value}")
        
        # assign_string takes one parameter (the index)
        if subop_name == "assign_string":
            return 1
        # Other subops may have different requirements
        return 0
    
    def fuse(self, previous: Instruction) -> Optional['ArrayOps']:
        """Fuse with previous push instructions."""
        return self._standard_fuse(previous)  # type: ignore[return-value]
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def render(self) -> List[Token]:
        
        # Handle both enum and integer subop types
        if hasattr(self.op_details.body.subop, 'name'):
            subop_name = self.op_details.body.subop.name
        else:
            # Map integer subop values to names
            subop_int_map = {
                0x00: "assign_string",
                # Add more mappings as needed
            }
            subop_value = self.op_details.body.subop
            subop_name = subop_int_map.get(subop_value, f"unknown_{subop_value}")
        
        # Special handling for assign_string
        if subop_name == "assign_string" and hasattr(self.op_details.body, 'array'):
            # Get array number and convert to name
            array_num = self.op_details.body.array
            array_name = SCUMM_ARRAY_NAMES.get(array_num, f"array_{array_num}")
            
            tokens: List[Token] = []
            
            # Show as array[index] = "string"
            tokens.append(TInt(array_name))
            tokens.append(TSep("["))
            
            # Add the index
            if self.fused_operands and len(self.fused_operands) >= 1:
                # Use fused operand for index
                tokens.extend(self._render_operand(self.fused_operands[0]))
            else:
                # Show as needing index from stack
                tokens.append(TText("..."))
            
            tokens.append(TSep("] = "))
            
            # Add the string value
            # The body might be UnknownOp if Kaitai didn't parse it correctly
            # In that case, try to extract the message manually
            if hasattr(self.op_details.body, 'body'):
                body = self.op_details.body.body
                if hasattr(body, 'parts'):
                    # Properly parsed Message object
                    string_text = self._extract_message_text(body)
                    tokens.append(TText(f'"{string_text}"'))
                else:
                    # UnknownOp - extract message manually from raw data
                    # The message starts right after the subop byte
                    if hasattr(body, 'data') and body.data:
                        # Extract text from raw bytes
                        text_chars = []
                        for byte in body.data:
                            if byte == 0:  # Null terminator
                                break
                            if 32 <= byte <= 126:  # Printable ASCII
                                text_chars.append(chr(byte))
                        string_text = ''.join(text_chars)
                        tokens.append(TText(f'"{string_text}"'))
                    else:
                        tokens.append(TText('"..."'))
            else:
                tokens.append(TText('"..."'))
            
            return tokens
        
        # Default rendering for other subops
        return [TInstr(f"array_ops.{subop_name}")]
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # This is a result-producing instruction
            tokens: List[Token] = []
            tokens.append(TText("("))
            tokens.extend(operand.render())
            tokens.append(TText(")"))
            return tokens
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return il.const(4, operand.op_details.body.data)
        elif hasattr(operand, 'produces_result') and operand.produces_result():
            # Complex case - placeholder
            return il.const(4, 0)
        else:
            return il.const(4, 0)
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ArrayOps), \
            f"Expected ArrayOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        if hasattr(subop, 'name'):
            intrinsic_name = f"array_ops.{subop.name}"
        else:
            # Map integer subop values to names
            subop_int_map = {
                0x00: "assign_string",
                # Add more mappings as needed
            }
            subop_value = subop
            subop_name = subop_int_map.get(subop_value, f"unknown_{subop_value}")
            intrinsic_name = f"array_ops.{subop_name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Build parameters
        if self.fused_operands:
            # Use fused operands directly
            params = []
            for operand in self.fused_operands:
                params.append(self._lift_operand(il, operand))
            # Pop any remaining arguments
            remaining_pops = pop_count - len(self.fused_operands)
            for _ in range(remaining_pops):
                params.append(il.pop(4))
        else:
            # Pop arguments normally
            params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class RoomOps(Instruction):
    """Room operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"room_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.RoomOps), \
            f"Expected RoomOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"room_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class SystemOps(Instruction):
    """System operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"system_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.SystemOps), \
            f"Expected SystemOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"system_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class ResourceRoutines(Instruction):
    """Resource management operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"resource_routines.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes  # type: ignore[attr-defined]
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ResourceRoutines), \
            f"Expected ResourceRoutines body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"resource_routines.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))
