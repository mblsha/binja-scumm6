"""Concrete SCUMM6 instruction implementations."""

from typing import List, Any
from binja_helpers.tokens import Token, TInstr, TSep, TInt, TText
from binaryninja.lowlevelil import LowLevelILFunction, LLIL_TEMP, LowLevelILLabel
from binaryninja import IntrinsicName, InstructionInfo
from ...scumm6_opcodes import Scumm6Opcodes

from .opcodes import Instruction
from .generic import VariableWriteOp, ControlFlowOp, IntrinsicOp
from .smart_bases import SmartConditionalJump

# Import the vars module to use the same LLIL generation logic
from ... import vars


# PushByte and PushWord are now generated by factories in opcode_table.py


class PushByteVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_byte_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteData), \
            f"Expected ByteData body, got {type(self.op_details.body)}"

        # Create a wrapper that adds the missing type attribute for compatibility
        # with the existing vars.il_get_var function
        class VarBlock:
            def __init__(self, data: int, var_type: Scumm6Opcodes.VarType):
                self.data = data
                self.type = var_type

        var_block = VarBlock(self.op_details.body.data, Scumm6Opcodes.VarType.scumm_var)
        il.append(il.push(4, vars.il_get_var(il, var_block)))


class PushWordVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_word_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        il.append(il.push(4, vars.il_get_var(il, self.op_details.body)))


class Dup(Instruction):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        return [TInstr("dup")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.NoData), \
            f"Expected NoData body, got {type(self.op_details.body)}"

        # Pop value into temp register, then push it twice
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# Pop1 and Pop2 are now generated by factories in opcode_table.py
# Add, Sub, Mul, Div, Land, Lor, Nott, Eq, Neq, Gt, Lt, Le, Ge are now generated by factories in opcode_table.py


# Abs is now generated by factory in opcode_table.py


class Band(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("band")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Bor(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("bor")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class WordVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class ByteVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


class WordVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


# BreakHere is now generated by factory in opcode_table.py


class Dummy(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dummy")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


# GetRandomNumber and GetRandomNumberRange are now generated by factories in opcode_table.py


class PickOneOf(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class PickOneOfDefault(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of_default")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Shuffle(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("shuffle")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayRead), \
            f"Expected ByteArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WriteByteVar(VariableWriteOp):
    instruction_name = "write_byte_var"
    expected_body_type = Scumm6Opcodes.ByteVarData


class WriteWordVar(VariableWriteOp):
    instruction_name = "write_word_var" 
    expected_body_type = Scumm6Opcodes.WordVarData


class WordArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayRead), \
            f"Expected WordArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedRead), \
            f"Expected ByteArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedRead), \
            f"Expected WordArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation  
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayWrite), \
            f"Expected ByteArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayWrite), \
            f"Expected WordArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedWrite), \
            f"Expected ByteArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedWrite), \
            f"Expected WordArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Iff(ControlFlowOp):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        # Follow descumm philosophy: show semantic meaning
        # Positive offset = forward jump, negative = backward jump
        if jump_offset > 0:
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        else:
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]

    def is_conditional(self) -> bool:
        return True

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition != 0, jump to target (iff = "if true")
        il.append(
            il.if_expr(
                il.compare_not_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class IfNot(ControlFlowOp):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        # Follow descumm philosophy: show semantic meaning
        if jump_offset > 0:
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        elif jump_offset < 0:
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]
        else:
            # Zero offset = skip next instruction if true
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr("self"),
            ]

    def is_conditional(self) -> bool:
        return True

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition == 0, jump to target (if_not = "if false")
        il.append(
            il.if_expr(
                il.compare_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class Jump(ControlFlowOp):

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        # Follow descumm philosophy: show semantic meaning
        if jump_offset > 0:
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        elif jump_offset < 0:
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]
        else:
            # Zero offset = infinite loop
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr("self"),
            ]

    def is_conditional(self) -> bool:
        return False

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Unconditional jump to target
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        # Use const_pointer to ensure proper cross-references for inter-procedural jumps
        il.append(il.jump(il.const_pointer(il.arch.address_size, target_addr)))


class SmartIff(SmartConditionalJump):
    """Fusible 'if true' conditional jump instruction."""
    
    def __init__(self, kaitai_op: Any, length: int) -> None:
        super().__init__(kaitai_op, length)
        self._name = "iff"
        self._is_if_not = False  # This is 'if', not 'if_not'


class SmartIfNot(SmartConditionalJump):
    """Fusible 'if false/unless' conditional jump instruction."""
    
    def __init__(self, kaitai_op: Any, length: int) -> None:
        super().__init__(kaitai_op, length)
        self._name = "if_not"
        self._is_if_not = True  # This is 'if_not'


# =============================================================================
# Group 3: Complex Engine Intrinsics
# =============================================================================

# DrawObject, DrawObjectAt, DrawBlastObject are now generated by factories in opcode_table.py


class Cutscene(IntrinsicOp):
    """Start cutscene with variable number of parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "cutscene"
    
    @property
    def pop_count(self) -> int:
        """Cutscene uses call_func_list which requires complex argument parsing."""
        # For call_func_list, we need to look at the actual body to determine argument count
        if hasattr(self.op_details.body, 'args') and hasattr(self.op_details.body.args, '__len__'):
            return len(self.op_details.body.args)
        else:
            # Default to 0 if we can't determine the argument count
            return 0


# EndCutscene, StopMusic, FreezeUnfreeze are now generated by factories in opcode_table.py


class StopObjectCode1(IntrinsicOp):
    """Stop object code (variant 1) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code1"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


class StopObjectCode2(IntrinsicOp):
    """Stop object code (variant 2) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code2"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


# StopObjectScript, StartSound, StopSound, PanCameraTo, ActorFollowCamera, SetCameraAt, LoadRoom, GetState, SetState, SetOwner are now generated by factories


# Simple Actor Query Operations - now generated by factories
# GetOwner, IsScriptRunning, IsSoundRunning, GetActorMoving, GetActorRoom, GetActorCostume, GetActorWalkBox, GetInventoryCount, FindInventory, GetObjectX, GetObjectY, GetObjectOldDir are now generated by factories


# AnimateActor, FaceActor, PickupObject, SetBoxFlags, SetObjectName, DoSentence, GetActorElevation, GetActorWidth, GetActorScaleX, GetActorAnimCounter, GetVerbFromXy, GetActorFromXy are now generated by factories


# Zero-Parameter Intrinsics and Timing Operations - now generated by factories
# BeginOverride, EndOverride, CreateBoxMatrix, StopTalking, StopSentence, Wait, Delay, DelaySeconds, DelayMinutes, DelayFrames, StartMusic, StopScript are now generated by factories


# Distance/Geometry/Query/Movement Operations - now generated by factories  
# IsRoomScriptRunning, GetObjectNewDir, DistObjectObject, DistObjectPt, DistPtPt, GetPixel, FindObject, GetVerbEntrypoint, IsActorInBox, WalkActorToObj, WalkActorTo, PutActorAtXy are now generated by factories


# PutActorAtObject - now generated by factories from configs.py


# Additional Simple Operations (now generated by factories from configs.py)
# GetDatetime - now generated by factories from configs.py


# GetAnimateVariable - now generated by factories from configs.py


# PickVarRandom - now generated by factories from configs.py


# GetActorLayer - now generated by factories from configs.py


# Final Simple Utility Operations (now generated by factories from configs.py)
# CursorCommand - now generated by factories from configs.py


# SoundKludge - now generated by factories from configs.py


class IfClassOfIs(Instruction):
    """Check if object belongs to a specific class - pushes boolean result to stack."""
    
    @property
    def stack_pop_count(self) -> int:
        return 2

    def render(self) -> List[Token]:
        return [TInstr("if_class_of_is")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.IfClassOfIs), \
            f"Expected IfClassOfIs body, got {type(self.op_details.body)}"
        
        # Pop class and object from stack (stack order: ..., object, class)
        class_val = il.pop(4)    # Pop class ID
        object_val = il.pop(4)   # Pop object ID
        
        # Call intrinsic to check if object is of specified class
        # This returns a boolean result (0 or 1)
        result = il.intrinsic([il.reg(4, LLIL_TEMP(0))], "if_class_of_is", [object_val, class_val])
        il.append(result)
        
        # Push boolean result back to stack for subsequent conditional jump
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# SetClass - now generated by factories from configs.py


# DrawBox - now generated by factories from configs.py


# IsAnyOf - now generated by factories from configs.py


# Additional Simple Script Operations (now generated by factories from configs.py)
# LoadRoomWithEgo - now generated by factories from configs.py


# SetBoxSet - now generated by factories from configs.py


# StampObject - now generated by factories from configs.py


# SetBlastObjectWindow - now generated by factories from configs.py


# PseudoRoom - now generated by factories from configs.py


# FindAllObjects - now generated by factories from configs.py


# Simple Script and Object Operations (now generated by factories from configs.py)
# JumpToScript - now generated by factories from configs.py


# StartObject - now generated by factories from configs.py


# StartObjectQuick - now generated by factories from configs.py


# Array Management Operations (now generated by factories from configs.py)
# DimArray - now generated by factories from configs.py


# Dim2dimArray - now generated by factories from configs.py


# Kernel Operations (now generated by factories from configs.py)
# KernelGetFunctions - now generated by factories from configs.py


# KernelSetFunctions - now generated by factories from configs.py


# Additional Utility Operations (now generated by factories from configs.py)
# SaveRestoreVerbs - now generated by factories from configs.py


# Dialog and Text Operations (now generated by factories from configs.py)
# PrintLine - now generated by factories from configs.py


# PrintText - now generated by factories from configs.py


class PrintDebug(Instruction):
    """Print debug with text parameter."""
    
    def _extract_message_text(self, message) -> str:
        """Extract text from a SCUMM6 Message object."""
        text_chars = []
        for part in message.parts:
            if hasattr(part, 'data') and part.data != 0:  # Skip terminator
                if hasattr(part, 'content'):
                    # Check if it's a RegularChar
                    if hasattr(part.content, 'value'):
                        # Convert byte value to character
                        char_value = part.content.value
                        if isinstance(char_value, int) and 32 <= char_value <= 126:  # Printable ASCII
                            text_chars.append(chr(char_value))
        return ''.join(text_chars)
    
    def render(self) -> List[Token]:
        # Check if this instruction contains a message
        from ...scumm6_opcodes import Scumm6Opcodes
        
        if hasattr(self.op_details.body, 'subop') and hasattr(self.op_details.body, 'body'):
            # This is a Print structure with a subop
            if (self.op_details.body.subop == Scumm6Opcodes.SubopType.textstring and 
                isinstance(self.op_details.body.body, Scumm6Opcodes.Message)):
                # Extract the actual message text
                message_text = self._extract_message_text(self.op_details.body.body)
                if message_text:
                    return [TInstr("printDebug"), TText(".msg("), TText(f'"{message_text}"'), TText(")")]
                else:
                    # Fallback to ellipsis if text extraction fails
                    return [TInstr("printDebug"), TText(".msg("), TText("..."), TText(")")]
            else:
                # Handle other subops like begin(), end(), etc.
                subop_name = self.op_details.body.subop.name
                # Map baseop to begin to match descumm format
                if subop_name == "baseop":
                    subop_name = "begin"
                return [TInstr("printDebug"), TText(f".{subop_name}()")]
        
        # Fallback for simple print_debug without subop
        return [TInstr("printDebug")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        # For LLIL, treat as a simple intrinsic
        il.append(il.intrinsic([], "print_debug", []))


# PrintSystem - now generated by factories from configs.py


# PrintActor - now generated by factories from configs.py


# PrintEgo - now generated by factories from configs.py


# TalkActor - now generated by factories from configs.py


# TalkEgo - now generated by factories from configs.py


# Complex Operations with Sub-commands
class ActorOps(Instruction):
    """Actor operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"actor_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ActorOps), \
            f"Expected ActorOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"actor_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class VerbOps(Instruction):
    """Verb operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"verb_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.VerbOps), \
            f"Expected VerbOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"verb_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class ArrayOps(Instruction):
    """Array operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"array_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ArrayOps), \
            f"Expected ArrayOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"array_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class RoomOps(Instruction):
    """Room operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"room_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.RoomOps), \
            f"Expected RoomOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"room_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class SystemOps(Instruction):
    """System operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"system_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.SystemOps), \
            f"Expected SystemOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"system_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class ResourceRoutines(Instruction):
    """Resource management operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"resource_routines.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ResourceRoutines), \
            f"Expected ResourceRoutines body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"resource_routines.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))
