"""Concrete SCUMM6 instruction implementations."""

from typing import List, Any, Optional, Tuple
import copy
from binja_helpers.tokens import Token, TInstr, TSep, TInt, TText
from binaryninja.lowlevelil import LowLevelILFunction, LLIL_TEMP, LowLevelILLabel
from binaryninja import IntrinsicName, InstructionInfo
from ...scumm6_opcodes import Scumm6Opcodes

from .opcodes import Instruction
from .generic import VariableWriteOp, ControlFlowOp, IntrinsicOp
from .smart_bases import SmartConditionalJump, FusibleMultiOperandMixin

# Import the vars module to use the same LLIL generation logic
from ... import vars


# PushByte and PushWord are now generated by factories in opcode_table.py


class PushByteVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_byte_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteData), \
            f"Expected ByteData body, got {type(self.op_details.body)}"

        # Create a wrapper that adds the missing type attribute for compatibility
        # with the existing vars.il_get_var function
        class VarBlock:
            def __init__(self, data: int, var_type: Scumm6Opcodes.VarType):
                self.data = data
                self.type = var_type

        var_block = VarBlock(self.op_details.body.data, Scumm6Opcodes.VarType.scumm_var)
        il.append(il.push(4, vars.il_get_var(il, var_block)))


class PushWordVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_word_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        il.append(il.push(4, vars.il_get_var(il, self.op_details.body)))


class Dup(Instruction):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        return [TInstr("dup")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.NoData), \
            f"Expected NoData body, got {type(self.op_details.body)}"

        # Pop value into temp register, then push it twice
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# Pop1 and Pop2 are now generated by factories in opcode_table.py
# Add, Sub, Mul, Div, Land, Lor, Nott, Eq, Neq, Gt, Lt, Le, Ge are now generated by factories in opcode_table.py


# Abs is now generated by factory in opcode_table.py


class Band(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("band")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Bor(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("bor")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class WordVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class ByteVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


class WordVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


# BreakHere is now generated by factory in opcode_table.py


class Dummy(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dummy")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


# GetRandomNumber and GetRandomNumberRange are now generated by factories in opcode_table.py


class PickOneOf(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class PickOneOfDefault(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of_default")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Shuffle(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("shuffle")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayRead), \
            f"Expected ByteArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WriteByteVar(VariableWriteOp):
    instruction_name = "write_byte_var"
    expected_body_type = Scumm6Opcodes.ByteVarData


class WriteWordVar(VariableWriteOp):
    instruction_name = "write_word_var" 
    expected_body_type = Scumm6Opcodes.WordVarData


class WordArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayRead), \
            f"Expected WordArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedRead), \
            f"Expected ByteArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedRead), \
            f"Expected WordArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation  
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayWrite), \
            f"Expected ByteArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayWrite), \
            f"Expected WordArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedWrite), \
            f"Expected ByteArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedWrite), \
            f"Expected WordArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Iff(ControlFlowOp):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        # Follow descumm philosophy: show semantic meaning
        # Positive offset = forward jump, negative = backward jump
        if jump_offset > 0:
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        else:
            return [
                TInstr("if"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]

    def is_conditional(self) -> bool:
        return True

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition != 0, jump to target (iff = "if true")
        il.append(
            il.if_expr(
                il.compare_not_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class IfNot(ControlFlowOp):

    @property
    def stack_pop_count(self) -> int:
        return 1

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        # Follow descumm philosophy: show semantic meaning
        if jump_offset > 0:
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        elif jump_offset < 0:
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]
        else:
            # Zero offset = skip next instruction if true
            return [
                TInstr("unless"),
                TSep(" "),
                TInstr("goto"),
                TSep(" "),
                TInstr("self"),
            ]

    def is_conditional(self) -> bool:
        return True

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition == 0, jump to target (if_not = "if false")
        il.append(
            il.if_expr(
                il.compare_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class Jump(ControlFlowOp):

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        # Follow descumm philosophy: show semantic meaning
        if jump_offset > 0:
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr(f"+{jump_offset}"),
            ]
        elif jump_offset < 0:
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr(f"{jump_offset}"),
            ]
        else:
            # Zero offset = infinite loop
            return [
                TInstr("goto"),
                TSep(" "),
                TInstr("self"),
            ]

    def is_conditional(self) -> bool:
        return False

    def analyze(self, info: InstructionInfo, addr: int) -> None:
        super().analyze(info, addr)

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Unconditional jump to target
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        # Use const_pointer to ensure proper cross-references for inter-procedural jumps
        il.append(il.jump(il.const_pointer(il.arch.address_size, target_addr)))


class SmartIff(SmartConditionalJump):
    """Fusible 'if true' conditional jump instruction."""
    
    def __init__(self, kaitai_op: Any, length: int) -> None:
        super().__init__(kaitai_op, length)
        self._name = "iff"
        self._is_if_not = False  # This is 'if', not 'if_not'


class SmartIfNot(SmartConditionalJump):
    """Fusible 'if false/unless' conditional jump instruction."""
    
    def __init__(self, kaitai_op: Any, length: int) -> None:
        super().__init__(kaitai_op, length)
        self._name = "if_not"
        self._is_if_not = True  # This is 'if_not'


# =============================================================================
# Group 3: Complex Engine Intrinsics
# =============================================================================

# DrawObject, DrawObjectAt, DrawBlastObject are now generated by factories in opcode_table.py


class Cutscene(IntrinsicOp):
    """Start cutscene with variable number of parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "cutscene"
    
    @property
    def pop_count(self) -> int:
        """Cutscene uses call_func_list which requires complex argument parsing."""
        # For call_func_list, we need to look at the actual body to determine argument count
        if hasattr(self.op_details.body, 'args') and hasattr(self.op_details.body.args, '__len__'):
            return len(self.op_details.body.args)
        else:
            # Default to 0 if we can't determine the argument count
            return 0


# EndCutscene, StopMusic, FreezeUnfreeze are now generated by factories in opcode_table.py


class StopObjectCode1(IntrinsicOp):
    """Stop object code (variant 1) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code1"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


class StopObjectCode2(IntrinsicOp):
    """Stop object code (variant 2) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code2"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


# StopObjectScript, StartSound, StopSound, PanCameraTo, ActorFollowCamera, SetCameraAt, LoadRoom, GetState, SetState, SetOwner are now generated by factories


# Simple Actor Query Operations - now generated by factories
# GetOwner, IsScriptRunning, IsSoundRunning, GetActorMoving, GetActorRoom, GetActorCostume, GetActorWalkBox, GetInventoryCount, FindInventory, GetObjectX, GetObjectY, GetObjectOldDir are now generated by factories


# AnimateActor, FaceActor, PickupObject, SetBoxFlags, SetObjectName, DoSentence, GetActorElevation, GetActorWidth, GetActorScaleX, GetActorAnimCounter, GetVerbFromXy, GetActorFromXy are now generated by factories


# Zero-Parameter Intrinsics and Timing Operations - now generated by factories
# BeginOverride, EndOverride, CreateBoxMatrix, StopTalking, StopSentence, Wait, Delay, DelaySeconds, DelayMinutes, DelayFrames, StartMusic, StopScript are now generated by factories


# Distance/Geometry/Query/Movement Operations - now generated by factories  
# IsRoomScriptRunning, GetObjectNewDir, DistObjectObject, DistObjectPt, DistPtPt, GetPixel, FindObject, GetVerbEntrypoint, IsActorInBox, WalkActorToObj, WalkActorTo, PutActorAtXy are now generated by factories


# PutActorAtObject - now generated by factories from configs.py


# Additional Simple Operations (now generated by factories from configs.py)
# GetDatetime - now generated by factories from configs.py


# GetAnimateVariable - now generated by factories from configs.py


# PickVarRandom - now generated by factories from configs.py


# GetActorLayer - now generated by factories from configs.py


# Final Simple Utility Operations (now generated by factories from configs.py)
# CursorCommand - now generated by factories from configs.py


# SoundKludge - now generated by factories from configs.py


class IfClassOfIs(Instruction):
    """Check if object belongs to a specific class - pushes boolean result to stack."""
    
    @property
    def stack_pop_count(self) -> int:
        return 2

    def render(self) -> List[Token]:
        return [TInstr("if_class_of_is")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.IfClassOfIs), \
            f"Expected IfClassOfIs body, got {type(self.op_details.body)}"
        
        # Pop class and object from stack (stack order: ..., object, class)
        class_val = il.pop(4)    # Pop class ID
        object_val = il.pop(4)   # Pop object ID
        
        # Call intrinsic to check if object is of specified class
        # This returns a boolean result (0 or 1)
        result = il.intrinsic([il.reg(4, LLIL_TEMP(0))], "if_class_of_is", [object_val, class_val])
        il.append(result)
        
        # Push boolean result back to stack for subsequent conditional jump
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# SetClass - now generated by factories from configs.py


# DrawBox - now generated by factories from configs.py


# IsAnyOf - now generated by factories from configs.py


# Additional Simple Script Operations (now generated by factories from configs.py)
# LoadRoomWithEgo - now generated by factories from configs.py


# SetBoxSet - now generated by factories from configs.py


# StampObject - now generated by factories from configs.py


# SetBlastObjectWindow - now generated by factories from configs.py


# PseudoRoom - now generated by factories from configs.py


# FindAllObjects - now generated by factories from configs.py


# Simple Script and Object Operations (now generated by factories from configs.py)
# JumpToScript - now generated by factories from configs.py


# StartObject - now generated by factories from configs.py


# StartObjectQuick - now generated by factories from configs.py


# Array Management Operations (now generated by factories from configs.py)
# DimArray - now generated by factories from configs.py


# Dim2dimArray - now generated by factories from configs.py


# Kernel Operations (now generated by factories from configs.py)
# KernelGetFunctions - now generated by factories from configs.py


# KernelSetFunctions - now generated by factories from configs.py


# Additional Utility Operations (now generated by factories from configs.py)
# SaveRestoreVerbs - now generated by factories from configs.py


# Dialog and Text Operations (now generated by factories from configs.py)
# PrintLine - now generated by factories from configs.py


# PrintText - now generated by factories from configs.py


class PrintDebug(Instruction):
    """Print debug with text parameter."""
    
    def _extract_message_text(self, message: Any) -> Tuple[List[str], str]:
        """Extract text from a SCUMM6 Message object, including sound commands.
        
        Returns:
            A tuple of (sound_commands, text_string)
        """
        sound_commands: List[str] = []
        text_chars: List[str] = []
        
        for part in message.parts:
            if hasattr(part, 'data'):
                if part.data == 0xFF:
                    # This might be a special sequence
                    if hasattr(part, 'content') and hasattr(part.content, 'payload'):
                        # Check if it's a Sound special sequence
                        payload = part.content.payload
                        if payload.__class__.__name__ == 'Sound':
                            # Extract sound parameters (v1 and v3, skip v2)
                            if hasattr(payload, 'v1') and hasattr(payload, 'v3'):
                                sound_commands.append(f"sound({hex(payload.v1).upper().replace('X', 'x')}, {hex(payload.v3).upper().replace('X', 'x')})")
                elif part.data != 0:  # Skip terminator
                    if hasattr(part, 'content'):
                        # Check if it's a RegularChar
                        if hasattr(part.content, 'value'):
                            # Convert byte value to character
                            char_value = part.content.value
                            if isinstance(char_value, int) and 32 <= char_value <= 126:  # Printable ASCII
                                text_chars.append(chr(char_value))
        
        # Return sound commands and text separately
        return sound_commands, ''.join(text_chars)
    
    def render(self) -> List[Token]:
        # Check if this instruction contains a message
        from ...scumm6_opcodes import Scumm6Opcodes
        
        if hasattr(self.op_details.body, 'subop') and hasattr(self.op_details.body, 'body'):
            # This is a Print structure with a subop
            if (self.op_details.body.subop == Scumm6Opcodes.SubopType.textstring and 
                isinstance(self.op_details.body.body, Scumm6Opcodes.Message)):
                # Extract the actual message text
                sound_commands, text = self._extract_message_text(self.op_details.body.body)
                
                tokens = [TInstr("printDebug"), TText(".msg(")]
                
                # Add sound commands and text
                if sound_commands:
                    # Add sound commands
                    for i, sound_cmd in enumerate(sound_commands):
                        if i > 0:
                            tokens.extend([TText(" + ")])
                        tokens.append(TInstr(sound_cmd))
                    
                    if text:
                        tokens.extend([TText(" + "), TText(f'"{text}"')])
                    else:
                        # Just sound, add empty string
                        tokens.extend([TText(" + "), TText('""')])
                elif text:
                    tokens.append(TText(f'"{text}"'))
                else:
                    # No text or sound
                    tokens.append(TText('""'))
                
                tokens.append(TText(")"))
                return tokens
            else:
                # Handle other subops like begin(), end(), etc.
                subop_name = self.op_details.body.subop.name
                # Map baseop to begin to match descumm format
                if subop_name == "baseop":
                    subop_name = "begin"
                return [TInstr("printDebug"), TText(f".{subop_name}()")]
        
        # Fallback for simple print_debug without subop
        return [TInstr("printDebug")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        # For LLIL, treat as a simple intrinsic
        il.append(il.intrinsic([], "print_debug", []))


# PrintSystem - now generated by factories from configs.py


# PrintActor - now generated by factories from configs.py


# PrintEgo - now generated by factories from configs.py


class TalkActor(FusibleMultiOperandMixin, Instruction):
    """Talk actor with string message and actor parameter."""
    
    def __init__(self, kaitai_op: Any, length: int) -> None:
        super().__init__(kaitai_op, length)
        self.fused_operands: List[Instruction] = []
        self._stack_pop_count = 1  # Pops actor ID from stack by default
    
    @property
    def stack_pop_count(self) -> int:
        """Return 0 when fused, 1 when not fused."""
        return 0 if self.fused_operands else self._stack_pop_count
    
    def _extract_message_text(self, message: Any) -> Tuple[List[str], str]:
        """Extract text from a SCUMM6 Message object, including sound commands.
        
        Returns:
            A tuple of (sound_commands, text_string)
        """
        sound_commands: List[str] = []
        text_chars: List[str] = []
        
        for part in message.parts:
            if hasattr(part, 'data'):
                if part.data == 0xFF:
                    # This might be a special sequence
                    if hasattr(part, 'content') and hasattr(part.content, 'payload'):
                        # Check if it's a Sound special sequence
                        payload = part.content.payload
                        if payload.__class__.__name__ == 'Sound':
                            # Extract sound parameters (v1 and v3, skip v2)
                            if hasattr(payload, 'v1') and hasattr(payload, 'v3'):
                                sound_commands.append(f"sound({hex(payload.v1).upper().replace('X', 'x')}, {hex(payload.v3).upper().replace('X', 'x')})")
                elif part.data != 0:  # Skip terminator
                    if hasattr(part, 'content'):
                        # Check if it's a RegularChar
                        if hasattr(part.content, 'value'):
                            # Convert byte value to character
                            char_value = part.content.value
                            if isinstance(char_value, int) and 32 <= char_value <= 126:  # Printable ASCII
                                text_chars.append(chr(char_value))
        
        # Return sound commands and text separately
        return sound_commands, ''.join(text_chars)
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return [TInt(f"var_{operand.op_details.body.data}")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            return [TInt(str(operand.op_details.body.data))]
        else:
            return [TText("operand")]
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            return il.reg(4, f"var_{operand.op_details.body.data}")
        else:
            return il.const(4, operand.op_details.body.data)
    
    def _is_fusible_push(self, instr: Instruction) -> bool:
        """Check if instruction is a push that can be fused."""
        return instr.__class__.__name__ in ['PushByte', 'PushWord', 'PushByteVar', 'PushWordVar']
    
    def render(self) -> List[Token]:
        # Extract the message text from the bytecode
        from ...scumm6_opcodes import Scumm6Opcodes
        
        sound_commands: List[str] = []
        text: str = ""
        # Check if the body is a Message
        if isinstance(self.op_details.body, Scumm6Opcodes.Message):
            sound_commands, text = self._extract_message_text(self.op_details.body)
        
        if self.fused_operands and len(self.fused_operands) >= 1:
            # We have the actor parameter fused
            tokens = [TInstr("talkActor"), TText("(")]
            
            # Add sound commands and text
            if sound_commands:
                # Add sound commands
                for i, sound_cmd in enumerate(sound_commands):
                    if i > 0:
                        tokens.extend([TText(" + ")])
                    tokens.append(TInstr(sound_cmd))
                
                if text:
                    tokens.extend([TText(" + "), TText(f'"{text}"')])
            elif text:
                tokens.append(TText(f'"{text}"'))
            else:
                tokens.append(TText("..."))
            
            # Add the actor parameter
            tokens.extend([TSep(", ")])
            tokens.extend(self._render_operand(self.fused_operands[0]))
            tokens.append(TText(")"))
            return tokens
        else:
            # No fusion - show simple form
            return [TInstr("talkActor"), TText("()")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        if self.fused_operands and len(self.fused_operands) >= 1:
            # Use fused actor parameter
            params = [self._lift_operand(il, self.fused_operands[0])]
            il.append(il.intrinsic([], "talk_actor", params))
        else:
            # Pop actor from stack
            params = [il.pop(4)]
            il.append(il.intrinsic([], "talk_actor", params))
    
    def fuse(self, previous: Instruction) -> Optional['TalkActor']:
        """Fuse with push instruction for actor parameter."""
        # Only fuse if we need an operand
        if len(self.fused_operands) >= 1:
            return None
            
        # Check if previous is a fusible push
        if not self._is_fusible_push(previous):
            return None
            
        # Create fused instruction
        fused = copy.deepcopy(self)
        fused.fused_operands.append(previous)
        fused._length = self._length + previous.length()
        return fused


# TalkEgo - now generated by factories from configs.py


# Complex Operations with Sub-commands
class ActorOps(FusibleMultiOperandMixin, Instruction):
    """Actor operations with various sub-commands."""
    
    def __init__(self, kaitai_op: Any, length: int) -> None:
        super().__init__(kaitai_op, length)
        self.fused_operands: List[Instruction] = []
    
    def _get_max_operands(self) -> int:
        """Return the maximum number of operands based on subop's pop_count."""
        subop_body = self.op_details.body.body
        return getattr(subop_body, "pop_count", 0)
    
    @property
    def stack_pop_count(self) -> int:
        """Return remaining pops needed after fusion."""
        max_operands = self._get_max_operands()
        fused_count = len(self.fused_operands)
        return max(0, max_operands - fused_count)
    
    def render(self) -> List[Token]:
        from .smart_bases import DESCUMM_FUNCTION_NAMES
        subop_name = self.op_details.body.subop.name
        full_name = f"actor_ops.{subop_name}"
        display_name = DESCUMM_FUNCTION_NAMES.get(full_name, full_name)
        
        tokens: List[Token] = [TInstr(display_name)]
        
        # Add parameters if we have fused operands
        if self.fused_operands:
            tokens.append(TText("("))
            for i, operand in enumerate(self.fused_operands):
                if i > 0:
                    tokens.append(TSep(", "))
                tokens.extend(self._render_operand(operand))
            tokens.append(TText(")"))
        
        return tokens
    
    def _render_operand(self, operand: Instruction) -> List[Token]:
        """Render a fused operand appropriately."""
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            if hasattr(operand.op_details.body, 'data'):
                return [TInt(f"var_{operand.op_details.body.data}")]
            else:
                return [TInt("var_?")]
        elif operand.__class__.__name__ in ['PushByte', 'PushWord']:
            if hasattr(operand.op_details.body, 'data'):
                value = operand.op_details.body.data
                return [TInt(str(value))]
            else:
                return [TInt("?")]
        else:
            return [TText("operand")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ActorOps), \
            f"Expected ActorOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"actor_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Build parameters
        if self.fused_operands:
            # Use fused operands directly
            params = []
            for operand in self.fused_operands:
                params.append(self._lift_operand(il, operand))
            # Pop any remaining arguments
            remaining_pops = pop_count - len(self.fused_operands)
            for _ in range(remaining_pops):
                params.append(il.pop(4))
        else:
            # Pop all arguments from stack
            params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))
    
    def _lift_operand(self, il: LowLevelILFunction, operand: Instruction) -> Any:
        """Lift a fused operand to IL expression."""
        from ... import vars
        
        if operand.__class__.__name__ in ['PushByteVar', 'PushWordVar']:
            # Variable push - use il_get_var
            return vars.il_get_var(il, operand.op_details.body)
        else:
            # Constant push - use const
            if hasattr(operand.op_details.body, 'data'):
                value = operand.op_details.body.data
                return il.const(4, value)
        
        # Fallback to undefined
        return il.undefined()


class VerbOps(Instruction):
    """Verb operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"verb_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.VerbOps), \
            f"Expected VerbOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"verb_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class ArrayOps(Instruction):
    """Array operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"array_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ArrayOps), \
            f"Expected ArrayOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"array_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class RoomOps(Instruction):
    """Room operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"room_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.RoomOps), \
            f"Expected RoomOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"room_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class SystemOps(Instruction):
    """System operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"system_ops.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.SystemOps), \
            f"Expected SystemOps body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"system_ops.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))


class ResourceRoutines(Instruction):
    """Resource management operations with various sub-commands."""
    
    def render(self) -> List[Token]:
        subop_name = self.op_details.body.subop.name
        return [TInstr(f"resource_routines.{subop_name}")]
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        from ...scumm6_opcodes import Scumm6Opcodes
        
        # Verify we have the expected body type
        assert isinstance(self.op_details.body, Scumm6Opcodes.ResourceRoutines), \
            f"Expected ResourceRoutines body, got {type(self.op_details.body)}"
        
        # Access the subop and its body
        subop = self.op_details.body.subop
        subop_body = self.op_details.body.body
        
        # Construct intrinsic name
        intrinsic_name = f"resource_routines.{subop.name}"
        
        # Handle parameters based on subop_body attributes
        pop_count = getattr(subop_body, "pop_count", 0)
        push_count = getattr(subop_body, "push_count", 0)
        
        # Pop arguments and call intrinsic
        params = [il.pop(4) for _ in range(pop_count)]
        
        if push_count > 0:
            il.append(il.intrinsic([il.reg(4, LLIL_TEMP(0))], intrinsic_name, params))
            il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        else:
            il.append(il.intrinsic([], intrinsic_name, params))
