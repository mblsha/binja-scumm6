"""Concrete SCUMM6 instruction implementations."""

from typing import List
from binja_helpers.tokens import Token, TInstr, TSep, TInt
from binaryninja.lowlevelil import LowLevelILFunction, LLIL_TEMP, LowLevelILLabel
from binaryninja import IntrinsicName
from ...scumm6_opcodes import Scumm6Opcodes

from .opcodes import Instruction
from .generic import BinaryStackOp, UnaryStackOp, ComparisonStackOp, VariableWriteOp, ControlFlowOp, IntrinsicOp

# Import the vars module to use the same LLIL generation logic
from ... import vars


# PushByte and PushWord are now generated by factories in opcode_table.py


class PushByteVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_byte_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteData), \
            f"Expected ByteData body, got {type(self.op_details.body)}"

        # Create a wrapper that adds the missing type attribute for compatibility
        # with the existing vars.il_get_var function
        class VarBlock:
            def __init__(self, data: int, var_type: Scumm6Opcodes.VarType):
                self.data = data
                self.type = var_type

        var_block = VarBlock(self.op_details.body.data, Scumm6Opcodes.VarType.scumm_var)
        il.append(il.push(4, vars.il_get_var(il, var_block)))


class PushWordVar(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("push_word_var"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        il.append(il.push(4, vars.il_get_var(il, self.op_details.body)))


class Dup(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dup")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.NoData), \
            f"Expected NoData body, got {type(self.op_details.body)}"

        # Pop value into temp register, then push it twice
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


# Pop1 and Pop2 are now generated by factories in opcode_table.py


class Add(BinaryStackOp):
    il_op_name = "add"


class Sub(BinaryStackOp):
    il_op_name = "sub"


class Mul(BinaryStackOp):
    il_op_name = "mult"  # Note: IL method is mult


class Div(BinaryStackOp):
    il_op_name = "div_signed"


class Land(BinaryStackOp):
    il_op_name = "and_expr"


class Lor(BinaryStackOp):
    il_op_name = "or_expr"


class Nott(UnaryStackOp):
    il_op_name = "nott"
    needs_comparison_with_zero = True


class Eq(ComparisonStackOp):
    il_op_name = "compare_equal"


class Neq(ComparisonStackOp):
    il_op_name = "compare_not_equal"


class Gt(ComparisonStackOp):
    il_op_name = "compare_signed_greater_than"


class Lt(ComparisonStackOp):
    il_op_name = "compare_signed_less_than"


class Le(ComparisonStackOp):
    il_op_name = "compare_signed_less_equal"


class Ge(ComparisonStackOp):
    il_op_name = "compare_signed_greater_equal"


# Abs is now generated by factory in opcode_table.py


class Band(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("band")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Bor(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("bor")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # The original implementation generates two unimplemented() calls for UnknownOp:
        # 1. One from the else clause (fallthrough)
        # 2. One from the UnknownOp check
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class WordVarInc(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_inc"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.add(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        incremented_value = il.add(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, incremented_value))


class ByteVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("byte_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteVarData), \
            f"Expected ByteVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


class WordVarDec(Instruction):

    def render(self) -> List[Token]:
        var_id = self.op_details.body.data
        return [
            TInstr("word_var_dec"),
            TSep("("),
            TInt(f"var_{var_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordVarData), \
            f"Expected WordVarData body, got {type(self.op_details.body)}"

        # Original implementation: vars.il_set_var(il, body, il.sub(4, vars.il_get_var(il, body), il.const(4, 1)))
        current_value = vars.il_get_var(il, self.op_details.body)
        decremented_value = il.sub(4, current_value, il.const(4, 1))
        il.append(vars.il_set_var(il, self.op_details.body, decremented_value))


# BreakHere is now generated by factory in opcode_table.py


class Dummy(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("dummy")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


# GetRandomNumber and GetRandomNumberRange are now generated by factories in opcode_table.py


class PickOneOf(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class PickOneOfDefault(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("pick_one_of_default")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Shuffle(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("shuffle")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # Original implementation: falls through to else case then gets caught by UnknownOp check
        # This generates two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayRead), \
            f"Expected ByteArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WriteByteVar(VariableWriteOp):
    instruction_name = "write_byte_var"
    expected_body_type = Scumm6Opcodes.ByteVarData


class WriteWordVar(VariableWriteOp):
    instruction_name = "write_word_var" 
    expected_body_type = Scumm6Opcodes.WordVarData


class WordArrayRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayRead), \
            f"Expected WordArrayRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match old implementation
        # The intrinsic pops one value from stack and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_read"),  # intrinsic name
            [il.pop(4)]  # parameter: pop base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedRead), \
            f"Expected ByteArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedRead(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_read"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedRead), \
            f"Expected WordArrayIndexedRead body, got {type(self.op_details.body)}"

        # Generate intrinsic call to match expected implementation  
        # The intrinsic pops two values from stack (index, base) and pushes the result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_read"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop index and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayWrite), \
            f"Expected ByteArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayWrite), \
            f"Expected WordArrayWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_write"),  # intrinsic name
            [il.pop(4), il.pop(4)]  # parameters: pop value and base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("byte_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.ByteArrayIndexedWrite), \
            f"Expected ByteArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("byte_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class WordArrayIndexedWrite(Instruction):

    def render(self) -> List[Token]:
        array_id = self.op_details.body.array
        return [
            TInstr("word_array_indexed_write"),
            TSep("("),
            TInt(f"array_{array_id}"),
            TSep(")"),
        ]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.WordArrayIndexedWrite), \
            f"Expected WordArrayIndexedWrite body, got {type(self.op_details.body)}"

        # Generate intrinsic call - pops value, index, and base, pushes result
        il.append(il.intrinsic(
            [il.reg(4, LLIL_TEMP(0))],  # output
            IntrinsicName("word_array_indexed_write"),  # intrinsic name
            [il.pop(4), il.pop(4), il.pop(4)]  # parameters: pop value, index, base from stack
        ))
        il.append(il.push(4, il.reg(4, LLIL_TEMP(0))))


class ByteArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayInc(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_inc")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class ByteArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("byte_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class WordArrayDec(Instruction):

    def render(self) -> List[Token]:
        return [TInstr("word_array_dec")]

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.UnknownOp), \
            f"Expected UnknownOp body, got {type(self.op_details.body)}"

        # These operations are not implemented in the original scumm6.py
        # They fall through to UnknownOp and generate two unimplemented() calls like other UnknownOp instructions
        il.append(il.unimplemented())
        il.append(il.unimplemented())


class Iff(ControlFlowOp):

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        return [
            TInstr("iff"),
            TSep("("),
            TInt(str(jump_offset)),
            TSep(")"),
        ]

    def is_conditional(self) -> bool:
        return True

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition != 0, jump to target (iff = "if true")
        il.append(
            il.if_expr(
                il.compare_not_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class IfNot(ControlFlowOp):

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        return [
            TInstr("if_not"),
            TSep("("),
            TInt(str(jump_offset)),
            TSep(")"),
        ]

    def is_conditional(self) -> bool:
        return True

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Create labels for true and false branches
        t = LowLevelILLabel()
        f = LowLevelILLabel()
        
        # Pop condition value from stack
        il.append(il.set_reg(4, LLIL_TEMP(0), il.pop(4)))
        
        # If condition == 0, jump to target (if_not = "if false")
        il.append(
            il.if_expr(
                il.compare_equal(4, il.reg(4, LLIL_TEMP(0)), il.const(4, 0)), t, f
            )
        )
        
        # True branch - jump to target
        il.mark_label(t)
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))
        
        # False branch - continue to next instruction
        il.mark_label(f)


class Jump(ControlFlowOp):

    def render(self) -> List[Token]:
        jump_offset = self.op_details.body.jump_offset
        return [
            TInstr("jump"),
            TSep("("),
            TInt(str(jump_offset)),
            TSep(")"),
        ]

    def is_conditional(self) -> bool:
        return False

    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        assert isinstance(self.op_details.body, Scumm6Opcodes.JumpData), \
            f"Expected JumpData body, got {type(self.op_details.body)}"

        # Unconditional jump to target
        target_addr = addr + 3 + self.op_details.body.jump_offset  # 3 = instruction length
        il.append(il.jump(il.const(4, target_addr)))


# =============================================================================
# Group 3: Complex Engine Intrinsics
# =============================================================================

class DrawObject(IntrinsicOp):
    """Draw object with 2 parameters: object ID and state."""
    
    @property
    def intrinsic_name(self) -> str:
        return "draw_object"


class DrawObjectAt(IntrinsicOp):
    """Draw object at position with 3 parameters: object ID, X, Y."""
    
    @property  
    def intrinsic_name(self) -> str:
        return "draw_object_at"


class DrawBlastObject(IntrinsicOp):
    """Draw blast object with complex parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "draw_blast_object"


class Cutscene(IntrinsicOp):
    """Start cutscene with variable number of parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "cutscene"
    
    @property
    def pop_count(self) -> int:
        """Cutscene uses call_func_list which requires complex argument parsing."""
        # For call_func_list, we need to look at the actual body to determine argument count
        if hasattr(self.op_details.body, 'args') and hasattr(self.op_details.body.args, '__len__'):
            return len(self.op_details.body.args)
        else:
            # Default to 0 if we can't determine the argument count
            return 0


class EndCutscene(IntrinsicOp):
    """End cutscene with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "end_cutscene"


class StopMusic(IntrinsicOp):
    """Stop music with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_music"


class FreezeUnfreeze(IntrinsicOp):
    """Freeze/unfreeze with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "freeze_unfreeze"


class StopObjectCode1(IntrinsicOp):
    """Stop object code (variant 1) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code1"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


class StopObjectCode2(IntrinsicOp):
    """Stop object code (variant 2) with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_code2"
    
    def lift(self, il: LowLevelILFunction, addr: int) -> None:
        """Override to add no_ret() call as in original implementation."""
        super().lift(il, addr)
        il.append(il.no_ret())


class StopObjectScript(IntrinsicOp):
    """Stop object script with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_object_script"


class StartSound(IntrinsicOp):
    """Start sound with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "start_sound"


class StopSound(IntrinsicOp):
    """Stop sound with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_sound"


class PanCameraTo(IntrinsicOp):
    """Pan camera to position with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "pan_camera_to"


class ActorFollowCamera(IntrinsicOp):
    """Actor follow camera with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "actor_follow_camera"


class SetCameraAt(IntrinsicOp):
    """Set camera at position with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "set_camera_at"


class LoadRoom(IntrinsicOp):
    """Load room with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "load_room"


class GetState(IntrinsicOp):
    """Get state with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_state"


class SetState(IntrinsicOp):
    """Set state with 2 parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "set_state"


class SetOwner(IntrinsicOp):
    """Set owner with 2 parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "set_owner"


class GetOwner(IntrinsicOp):
    """Get owner with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_owner"


# Simple Actor Query Operations
class IsScriptRunning(IntrinsicOp):
    """Check if script is running with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "is_script_running"


class IsSoundRunning(IntrinsicOp):
    """Check if sound is running with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "is_sound_running"


class GetActorMoving(IntrinsicOp):
    """Get actor moving state with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_moving"


class GetActorRoom(IntrinsicOp):
    """Get actor room with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_room"


class GetActorCostume(IntrinsicOp):
    """Get actor costume with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_costume"


class GetActorWalkBox(IntrinsicOp):
    """Get actor walk box with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_walk_box"


class GetInventoryCount(IntrinsicOp):
    """Get inventory count with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_inventory_count"


class FindInventory(IntrinsicOp):
    """Find inventory item with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "find_inventory"


class GetObjectX(IntrinsicOp):
    """Get object X position with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_object_x"


class GetObjectY(IntrinsicOp):
    """Get object Y position with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_object_y"


class GetObjectOldDir(IntrinsicOp):
    """Get object old direction with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_object_old_dir"


class AnimateActor(IntrinsicOp):
    """Animate actor with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "animate_actor"


class FaceActor(IntrinsicOp):
    """Face actor with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "face_actor"


class PickupObject(IntrinsicOp):
    """Pick up object with 1 parameter."""
    
    @property
    def intrinsic_name(self) -> str:
        return "pickup_object"


# Two-Parameter Intrinsics
class SetBoxFlags(IntrinsicOp):
    """Set box flags with 2 parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "set_box_flags"


class SetObjectName(IntrinsicOp):
    """Set object name with 2 parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "set_object_name"


class DoSentence(IntrinsicOp):
    """Do sentence with 2 parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "do_sentence"


# Actor Query Operations with Return Values
class GetActorElevation(IntrinsicOp):
    """Get actor elevation with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_elevation"


class GetActorWidth(IntrinsicOp):
    """Get actor width with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_width"


class GetActorScaleX(IntrinsicOp):
    """Get actor scale X with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_scale_x"


class GetActorAnimCounter(IntrinsicOp):
    """Get actor animation counter with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_anim_counter"


class GetVerbFromXy(IntrinsicOp):
    """Get verb from coordinates with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_verb_from_xy"


class GetActorFromXy(IntrinsicOp):
    """Get actor from coordinates with 1 parameter, returns 1 value."""
    
    @property
    def intrinsic_name(self) -> str:
        return "get_actor_from_xy"


# Zero-Parameter Intrinsics
class BeginOverride(IntrinsicOp):
    """Begin override with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "begin_override"


class EndOverride(IntrinsicOp):
    """End override with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "end_override"


class CreateBoxMatrix(IntrinsicOp):
    """Create box matrix with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "create_box_matrix"


class StopTalking(IntrinsicOp):
    """Stop talking with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_talking"


class StopSentence(IntrinsicOp):
    """Stop sentence with no parameters."""
    
    @property
    def intrinsic_name(self) -> str:
        return "stop_sentence"
